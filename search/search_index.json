{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pymediawikidocker API Documentation","text":""},{"location":"#mwdocker.config","title":"<code>config</code>","text":"<p>Created on 2023-04-06</p> <p>@author: wf</p>"},{"location":"#mwdocker.config.Host","title":"<code>Host</code>","text":"<p>Host name getter</p> Source code in <code>mwdocker/config.py</code> <pre><code>class Host:\n    \"\"\"\n    Host name getter\n    \"\"\"\n\n    @classmethod\n    def get_default_host(cls) -&gt; str:\n        \"\"\"\n        get the default host as the fully qualifying hostname\n        of the computer the server runs on\n\n        Returns:\n            str: the hostname\n        \"\"\"\n        host = socket.getfqdn()\n        # work around https://github.com/python/cpython/issues/79345\n        if (\n            host\n            == \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\"\n        ):\n            host = \"localhost\"  # host=\"127.0.0.1\"\n        return host\n</code></pre>"},{"location":"#mwdocker.config.Host.get_default_host","title":"<code>get_default_host()</code>  <code>classmethod</code>","text":"<p>get the default host as the fully qualifying hostname of the computer the server runs on</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the hostname</p> Source code in <code>mwdocker/config.py</code> <pre><code>@classmethod\ndef get_default_host(cls) -&gt; str:\n    \"\"\"\n    get the default host as the fully qualifying hostname\n    of the computer the server runs on\n\n    Returns:\n        str: the hostname\n    \"\"\"\n    host = socket.getfqdn()\n    # work around https://github.com/python/cpython/issues/79345\n    if (\n        host\n        == \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\"\n    ):\n        host = \"localhost\"  # host=\"127.0.0.1\"\n    return host\n</code></pre>"},{"location":"#mwdocker.config.MwClusterConfig","title":"<code>MwClusterConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MwConfig</code></p> <p>MediaWiki Cluster configuration for multiple wikis</p> Source code in <code>mwdocker/config.py</code> <pre><code>@dataclass\nclass MwClusterConfig(MwConfig):\n    \"\"\"\n    MediaWiki Cluster configuration for multiple wikis\n    \"\"\"\n\n    versions: Optional[List[str]] = field(\n        default_factory=lambda: [\"1.35.13\", \"1.38.6\", \"1.39.7\", \"1.40.3\", \"1.41.1\"]\n    )\n    base_port: int = 9080\n\n    def addArgs(self, parser):\n        \"\"\"\n        add my arguments to the given parser\n        \"\"\"\n        super().addArgs(parser)\n        parser.add_argument(\n            \"-bp\",\n            \"--base_port\",\n            dest=\"base_port\",\n            type=int,\n            default=self.base_port,\n            help=\"set how base html port 80 to be exposed - incrementing by one for each version [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-vl\",\n            \"--version_list\",\n            dest=\"versions\",\n            nargs=\"*\",\n            default=self.versions,\n            help=\"mediawiki versions to create docker applications for [default: %(default)s] \",\n        )\n</code></pre>"},{"location":"#mwdocker.config.MwClusterConfig.addArgs","title":"<code>addArgs(parser)</code>","text":"<p>add my arguments to the given parser</p> Source code in <code>mwdocker/config.py</code> <pre><code>def addArgs(self, parser):\n    \"\"\"\n    add my arguments to the given parser\n    \"\"\"\n    super().addArgs(parser)\n    parser.add_argument(\n        \"-bp\",\n        \"--base_port\",\n        dest=\"base_port\",\n        type=int,\n        default=self.base_port,\n        help=\"set how base html port 80 to be exposed - incrementing by one for each version [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-vl\",\n        \"--version_list\",\n        dest=\"versions\",\n        nargs=\"*\",\n        default=self.versions,\n        help=\"mediawiki versions to create docker applications for [default: %(default)s] \",\n    )\n</code></pre>"},{"location":"#mwdocker.config.MwConfig","title":"<code>MwConfig</code>  <code>dataclass</code>","text":"<p>MediaWiki configuration for a Single Wiki</p> Source code in <code>mwdocker/config.py</code> <pre><code>@dataclass\nclass MwConfig:\n    \"\"\"\n    MediaWiki configuration for a Single Wiki\n    \"\"\"\n\n    version: str = \"1.39.7\"\n    smw_version: Optional[str] = None\n    extensionNameList: Optional[List[str]] = field(\n        default_factory=lambda: [\n            \"Admin Links\",\n            \"Header Tabs\",\n            \"ParserFunctions\",\n            \"SyntaxHighlight\",\n            \"Variables\",\n        ]\n    )\n    extensionJsonFile: Optional[str] = None\n    user: str = \"Sysop\"\n    prefix: str = \"mw\"\n    password_length: int = 15\n    random_password: bool = False\n    force_user: bool = False\n    password: str = \"sysop-1234!\"\n    mySQLRootPassword: Optional[str] = None\n    mySQLPassword: Optional[str] = None\n    logo: str = \"$wgResourceBasePath/resources/assets/wiki.png\"\n    port: int = 9080\n    sql_port: int = 9306\n    url = None\n    full_url = None\n    prot: str = \"http\"\n    host: str = Host.get_default_host()\n    script_path: str = \"\"\n    container_base_name: str = None\n    networkName: str = \"mwNetwork\"\n    mariaDBVersion: str = \"10.11\"\n    forceRebuild: bool = False\n    debug: bool = False\n    verbose: bool = True\n    wikiId: Optional[str] = None\n    docker_path: Optional[str] = None\n\n    def default_docker_path(self) -&gt; str:\n        \"\"\"\n        get the default docker path\n\n        Returns:\n            str: $HOME/.pymediawikidocker\n        \"\"\"\n        home = str(Path.home())\n        docker_path = f\"{home}/.pymediawikidocker\"\n        return docker_path\n\n    def __post_init__(self):\n        \"\"\"\n        post initialization configuration\n        \"\"\"\n        self.fullVersion = f\"MediaWiki {self.version}\"\n        self.underscoreVersion = self.version.replace(\".\", \"_\")\n        self.shortVersion = self.getShortVersion()\n        if not self.docker_path:\n            self.docker_path = self.default_docker_path()\n        if not self.container_base_name:\n            self.container_base_name = f\"{self.prefix}-{self.shortVersion}\"\n        self.reset_url(self.url)\n\n    def reset_url(self, url: str):\n        \"\"\"\n        reset my url\n\n        Args:\n            url(str): the url to set\n        \"\"\"\n        if url:\n            pr = urlparse(url)\n            self.prot = pr.scheme\n            self.host = pr.hostname\n            self.script_path = pr.path\n            self.base_url = f\"{self.prot}://{self.host}\"\n            self.full_url = url\n        else:\n            self.base_url = f\"{self.prot}://{self.host}\"\n            self.full_url = f\"{self.base_url}{self.script_path}:{self.port}\"\n\n    def reset_container_base_name(self, container_base_name: str = None):\n        \"\"\"\n        reset the container base name to the given name\n\n        Args:\n            container_base_name(str): the new container base name\n        \"\"\"\n        self.container_base_name = container_base_name\n        self.__post_init__()\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"\n        return my fields as a dict\n        dataclasses to dict conversion convenienc and information hiding\n\n        Returns:\n            dict: my fields in dict format\n        \"\"\"\n        config_dict = dataclasses.asdict(self)\n        return config_dict\n\n    def as_json(self) -&gt; str:\n        \"\"\"\n        return me as a json string\n\n        Returns:\n            str: my json representation\n        \"\"\"\n        config_dict = self.as_dict()\n        json_str = json.dumps(config_dict, indent=2)\n        return json_str\n\n    def get_config_path(self) -&gt; str:\n        \"\"\"\n        get my configuration base path\n\n        Returns:\n            str: the path to my configuration\n        \"\"\"\n        config_base_path = f\"{self.docker_path}/{self.container_base_name}\"\n        os.makedirs(config_base_path, exist_ok=True)\n        path = f\"{config_base_path}/MwConfig.json\"\n        return path\n\n    def save(self, path: str = None) -&gt; str:\n        \"\"\"\n        save my json\n\n        Args:\n            path(str): the path to store to - if None use {docker_path}/{container_base_name}/MwConfig.json\n        Returns:\n            str: the path\n        \"\"\"\n        if path is None:\n            path = self.get_config_path()\n\n        json_str = self.as_json()\n        print(json_str, file=open(path, \"w\"))\n        return path\n\n    def load(self, path: str = None) -&gt; \"MwConfig\":\n        \"\"\"\n        load the the MwConfig from the given path of if path is None (default)\n        use the config_path for the current configuration\n\n        restores the ExtensionMap on load\n\n        Args:\n            path(str): the path to load from\n\n        Returns:\n            MwConfig: a MediaWiki Configuration\n        \"\"\"\n        if path is None:\n            path = self.get_config_path()\n        with open(path, \"r\") as json_file:\n            json_str = json_file.read()\n            config_dict = json.loads(json_str)\n            config = dacite.from_dict(data_class=self.__class__, data=config_dict)\n            # restore extension map\n            config.getExtensionMap(config.extensionNameList, config.extensionJsonFile)\n            return config\n\n    def getShortVersion(self, separator=\"\"):\n        \"\"\"\n        get my short version e.g. convert 1.27.7 to 127\n\n        Returns:\n            str: the short version string\n        \"\"\"\n        versionMatch = re.match(\"(?P&lt;major&gt;[0-9]+)\\.(?P&lt;minor&gt;[0-9]+)\", self.version)\n        shortVersion = (\n            f\"{versionMatch.group('major')}{separator}{versionMatch.group('minor')}\"\n        )\n        return shortVersion\n\n    def create_random_password(self, length: int = 15) -&gt; str:\n        \"\"\"\n        create a random password\n\n        Args:\n            length(int): the length of the password\n\n        Returns:\n            str:a random password with the given length\n        \"\"\"\n        return secrets.token_urlsafe(length)\n\n    def getWikiId(self):\n        \"\"\"\n        get the wikiId\n\n        Returns:\n            str: e.g. mw-9080\n        \"\"\"\n        if self.wikiId is None:\n            wikiId = f\"{self.prefix}-{self.port}\"\n        else:\n            wikiId = self.wikiId\n        return wikiId\n\n    def getExtensionMap(\n        self, extensionNameList: list = None, extensionJsonFile: str = None\n    ):\n        \"\"\"\n        get map of extensions to handle\n\n        Args:\n            extensionNameList(list): a list of extension names\n            extensionJsonFile(str): the name of an extra extensionJsonFile (if any)\n        \"\"\"\n        self.extensionMap = {}\n        extensionList = ExtensionList.restore()\n        if extensionJsonFile is not None:\n            extraExtensionList = ExtensionList.load_from_json_file(extensionJsonFile)\n            for ext in extraExtensionList.extensions:\n                extensionList.extensions.append(ext)\n        self.extByName, duplicates = LOD.getLookup(extensionList.extensions, \"name\")\n        if len(duplicates) &gt; 0:\n            print(f\"{len(duplicates)} duplicate extensions: \")\n            for duplicate in duplicates:\n                print(duplicate.name)\n        if extensionNameList is not None:\n            self.addExtensions(extensionNameList)\n        return self.extensionMap\n\n    def addExtensions(self, extensionNameList):\n        \"\"\"\n        add extensions for the given list of extension names\n        \"\"\"\n        for extensionName in extensionNameList:\n            if extensionName in self.extByName:\n                self.extensionMap[extensionName] = self.extByName[extensionName]\n            else:\n                print(f\"warning: extension {extensionName} not known\")\n\n    def fromArgs(self, args):\n        \"\"\"\n        initialize me from the given commmand line arguments\n\n        Args:\n            args(Namespace): the command line arguments\n        \"\"\"\n        self.prefix = args.prefix\n        self.container_base_name = args.container_name\n        self.docker_path = args.docker_path\n        self.extensionNameList = args.extensionNameList\n        self.extensionJsonFile = args.extensionJsonFile\n        self.forceRebuild = args.forceRebuild\n        self.host = args.host\n        self.logo = args.logo\n        self.mariaDBVersion = args.mariaDBVersion\n        # passwords\n        self.mySQLRootPassword = args.mysqlPassword\n        if not self.mySQLRootPassword:\n            self.mySQLRootPassword = self.create_random_password(self.password_length)\n        self.mySQLPassword = self.create_random_password(self.password_length)\n        self.prot = args.prot\n        self.script_path = args.script_path\n        self.versions = args.versions\n        self.user = args.user\n        self.random_password = args.random_password\n        self.force_user = args.force_user\n        self.password = args.password\n        self.password_length = args.password_length\n        self.base_port = args.base_port\n        self.sql_port = args.sql_port\n        self.smw_version = args.smw_version\n        self.verbose = not args.quiet\n        self.debug = args.debug\n        self.getExtensionMap(self.extensionNameList, self.extensionJsonFile)\n        self.reset_url(args.url)\n\n    def addArgs(self, parser):\n        \"\"\"\n        add Arguments to the given parser\n        \"\"\"\n        parser.add_argument(\n            \"-cn\",\n            \"--container_name\",\n            default=self.container_base_name,\n            help=\"set container name (only valid and recommended for single version call)\",\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            dest=\"debug\",\n            action=\"store_true\",\n            default=self.debug,\n            help=\"enable debug mode [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-el\",\n            \"--extensionList\",\n            dest=\"extensionNameList\",\n            nargs=\"*\",\n            default=self.extensionNameList,\n            help=\"list of extensions to be installed [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-ej\",\n            \"--extensionJson\",\n            dest=\"extensionJsonFile\",\n            default=self.extensionJsonFile,\n            help=\"additional extension descriptions default: [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-f\",\n            \"--forceRebuild\",\n            action=\"store_true\",\n            default=self.forceRebuild,\n            help=\"force rebuilding  [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-fu\",\n            \"--force_user\",\n            action=\"store_true\",\n            default=self.force_user,\n            help=\"force overwrite of wikiuser\",\n        )\n        parser.add_argument(\n            \"--host\",\n            default=Host.get_default_host(),\n            help=\"the host to serve / listen from [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-dp\",\n            \"--docker_path\",\n            default=self.default_docker_path(),\n            help=\"the base directory to store docker and jinja template files [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--logo\", default=self.logo, help=\"set Logo [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"-mv\",\n            \"--mariaDBVersion\",\n            dest=\"mariaDBVersion\",\n            default=self.mariaDBVersion,\n            help=\"mariaDB Version to be installed [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--mysqlPassword\",\n            default=self.mySQLRootPassword,\n            help=\"set sqlRootPassword [default: %(default)s] - random password if None\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--random_password\",\n            action=\"store_true\",\n            default=self.random_password,\n            help=\"create random password and create wikiuser while at it\",\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--password\",\n            dest=\"password\",\n            default=self.password,\n            help=\"set password for initial user [default: %(default)s] \",\n        )\n        parser.add_argument(\n            \"-pl\",\n            \"--password_length\",\n            default=self.password_length,\n            help=\"set the password length for random passwords[default: %(default)s] \",\n        )\n        parser.add_argument(\n            \"--prefix\",\n            default=self.prefix,\n            help=\"the container name prefix to use [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--prot\",\n            default=self.prot,\n            help=\"change to https in case [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--script_path\",\n            default=self.script_path,\n            help=\"change to any script_path you might need to set [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--url\",\n            default=self.url,\n            help=\"will set prot host,script_path, and optionally port based on the url given [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-sp\",\n            \"--sql_base_port\",\n            dest=\"sql_port\",\n            type=int,\n            default=self.sql_port,\n            help=\"set base mySql port 3306 to be exposed - incrementing by one for each version [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-smw\",\n            \"--smw_version\",\n            dest=\"smw_version\",\n            default=self.smw_version,\n            help=\"set SemanticMediaWiki Version to be installed default is None - no installation of SMW\",\n        )\n        parser.add_argument(\n            \"-u\",\n            \"--user\",\n            dest=\"user\",\n            default=self.user,\n            help=\"set username of initial user with sysop rights [default: %(default)s] \",\n        )\n        parser.add_argument(\n            \"-q\",\n            \"--quiet\",\n            default=not self.verbose,\n            help=\"not verbose [default: %(default)s]\",\n            action=\"store_true\",\n        )\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>post initialization configuration</p> Source code in <code>mwdocker/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    post initialization configuration\n    \"\"\"\n    self.fullVersion = f\"MediaWiki {self.version}\"\n    self.underscoreVersion = self.version.replace(\".\", \"_\")\n    self.shortVersion = self.getShortVersion()\n    if not self.docker_path:\n        self.docker_path = self.default_docker_path()\n    if not self.container_base_name:\n        self.container_base_name = f\"{self.prefix}-{self.shortVersion}\"\n    self.reset_url(self.url)\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.addArgs","title":"<code>addArgs(parser)</code>","text":"<p>add Arguments to the given parser</p> Source code in <code>mwdocker/config.py</code> <pre><code>def addArgs(self, parser):\n    \"\"\"\n    add Arguments to the given parser\n    \"\"\"\n    parser.add_argument(\n        \"-cn\",\n        \"--container_name\",\n        default=self.container_base_name,\n        help=\"set container name (only valid and recommended for single version call)\",\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--debug\",\n        dest=\"debug\",\n        action=\"store_true\",\n        default=self.debug,\n        help=\"enable debug mode [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-el\",\n        \"--extensionList\",\n        dest=\"extensionNameList\",\n        nargs=\"*\",\n        default=self.extensionNameList,\n        help=\"list of extensions to be installed [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-ej\",\n        \"--extensionJson\",\n        dest=\"extensionJsonFile\",\n        default=self.extensionJsonFile,\n        help=\"additional extension descriptions default: [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--forceRebuild\",\n        action=\"store_true\",\n        default=self.forceRebuild,\n        help=\"force rebuilding  [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-fu\",\n        \"--force_user\",\n        action=\"store_true\",\n        default=self.force_user,\n        help=\"force overwrite of wikiuser\",\n    )\n    parser.add_argument(\n        \"--host\",\n        default=Host.get_default_host(),\n        help=\"the host to serve / listen from [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-dp\",\n        \"--docker_path\",\n        default=self.default_docker_path(),\n        help=\"the base directory to store docker and jinja template files [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--logo\", default=self.logo, help=\"set Logo [default: %(default)s]\"\n    )\n    parser.add_argument(\n        \"-mv\",\n        \"--mariaDBVersion\",\n        dest=\"mariaDBVersion\",\n        default=self.mariaDBVersion,\n        help=\"mariaDB Version to be installed [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--mysqlPassword\",\n        default=self.mySQLRootPassword,\n        help=\"set sqlRootPassword [default: %(default)s] - random password if None\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--random_password\",\n        action=\"store_true\",\n        default=self.random_password,\n        help=\"create random password and create wikiuser while at it\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--password\",\n        dest=\"password\",\n        default=self.password,\n        help=\"set password for initial user [default: %(default)s] \",\n    )\n    parser.add_argument(\n        \"-pl\",\n        \"--password_length\",\n        default=self.password_length,\n        help=\"set the password length for random passwords[default: %(default)s] \",\n    )\n    parser.add_argument(\n        \"--prefix\",\n        default=self.prefix,\n        help=\"the container name prefix to use [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--prot\",\n        default=self.prot,\n        help=\"change to https in case [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--script_path\",\n        default=self.script_path,\n        help=\"change to any script_path you might need to set [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--url\",\n        default=self.url,\n        help=\"will set prot host,script_path, and optionally port based on the url given [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-sp\",\n        \"--sql_base_port\",\n        dest=\"sql_port\",\n        type=int,\n        default=self.sql_port,\n        help=\"set base mySql port 3306 to be exposed - incrementing by one for each version [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-smw\",\n        \"--smw_version\",\n        dest=\"smw_version\",\n        default=self.smw_version,\n        help=\"set SemanticMediaWiki Version to be installed default is None - no installation of SMW\",\n    )\n    parser.add_argument(\n        \"-u\",\n        \"--user\",\n        dest=\"user\",\n        default=self.user,\n        help=\"set username of initial user with sysop rights [default: %(default)s] \",\n    )\n    parser.add_argument(\n        \"-q\",\n        \"--quiet\",\n        default=not self.verbose,\n        help=\"not verbose [default: %(default)s]\",\n        action=\"store_true\",\n    )\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.addExtensions","title":"<code>addExtensions(extensionNameList)</code>","text":"<p>add extensions for the given list of extension names</p> Source code in <code>mwdocker/config.py</code> <pre><code>def addExtensions(self, extensionNameList):\n    \"\"\"\n    add extensions for the given list of extension names\n    \"\"\"\n    for extensionName in extensionNameList:\n        if extensionName in self.extByName:\n            self.extensionMap[extensionName] = self.extByName[extensionName]\n        else:\n            print(f\"warning: extension {extensionName} not known\")\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.as_dict","title":"<code>as_dict()</code>","text":"<p>return my fields as a dict dataclasses to dict conversion convenienc and information hiding</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>my fields in dict format</p> Source code in <code>mwdocker/config.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"\n    return my fields as a dict\n    dataclasses to dict conversion convenienc and information hiding\n\n    Returns:\n        dict: my fields in dict format\n    \"\"\"\n    config_dict = dataclasses.asdict(self)\n    return config_dict\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.as_json","title":"<code>as_json()</code>","text":"<p>return me as a json string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>my json representation</p> Source code in <code>mwdocker/config.py</code> <pre><code>def as_json(self) -&gt; str:\n    \"\"\"\n    return me as a json string\n\n    Returns:\n        str: my json representation\n    \"\"\"\n    config_dict = self.as_dict()\n    json_str = json.dumps(config_dict, indent=2)\n    return json_str\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.create_random_password","title":"<code>create_random_password(length=15)</code>","text":"<p>create a random password</p> <p>Parameters:</p> Name Type Description Default <code>length(int)</code> <p>the length of the password</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a random password with the given length</p> Source code in <code>mwdocker/config.py</code> <pre><code>def create_random_password(self, length: int = 15) -&gt; str:\n    \"\"\"\n    create a random password\n\n    Args:\n        length(int): the length of the password\n\n    Returns:\n        str:a random password with the given length\n    \"\"\"\n    return secrets.token_urlsafe(length)\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.default_docker_path","title":"<code>default_docker_path()</code>","text":"<p>get the default docker path</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>$HOME/.pymediawikidocker</p> Source code in <code>mwdocker/config.py</code> <pre><code>def default_docker_path(self) -&gt; str:\n    \"\"\"\n    get the default docker path\n\n    Returns:\n        str: $HOME/.pymediawikidocker\n    \"\"\"\n    home = str(Path.home())\n    docker_path = f\"{home}/.pymediawikidocker\"\n    return docker_path\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.fromArgs","title":"<code>fromArgs(args)</code>","text":"<p>initialize me from the given commmand line arguments</p> <p>Parameters:</p> Name Type Description Default <code>args(Namespace)</code> <p>the command line arguments</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def fromArgs(self, args):\n    \"\"\"\n    initialize me from the given commmand line arguments\n\n    Args:\n        args(Namespace): the command line arguments\n    \"\"\"\n    self.prefix = args.prefix\n    self.container_base_name = args.container_name\n    self.docker_path = args.docker_path\n    self.extensionNameList = args.extensionNameList\n    self.extensionJsonFile = args.extensionJsonFile\n    self.forceRebuild = args.forceRebuild\n    self.host = args.host\n    self.logo = args.logo\n    self.mariaDBVersion = args.mariaDBVersion\n    # passwords\n    self.mySQLRootPassword = args.mysqlPassword\n    if not self.mySQLRootPassword:\n        self.mySQLRootPassword = self.create_random_password(self.password_length)\n    self.mySQLPassword = self.create_random_password(self.password_length)\n    self.prot = args.prot\n    self.script_path = args.script_path\n    self.versions = args.versions\n    self.user = args.user\n    self.random_password = args.random_password\n    self.force_user = args.force_user\n    self.password = args.password\n    self.password_length = args.password_length\n    self.base_port = args.base_port\n    self.sql_port = args.sql_port\n    self.smw_version = args.smw_version\n    self.verbose = not args.quiet\n    self.debug = args.debug\n    self.getExtensionMap(self.extensionNameList, self.extensionJsonFile)\n    self.reset_url(args.url)\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.getExtensionMap","title":"<code>getExtensionMap(extensionNameList=None, extensionJsonFile=None)</code>","text":"<p>get map of extensions to handle</p> <p>Parameters:</p> Name Type Description Default <code>extensionNameList(list)</code> <p>a list of extension names</p> required <code>extensionJsonFile(str)</code> <p>the name of an extra extensionJsonFile (if any)</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def getExtensionMap(\n    self, extensionNameList: list = None, extensionJsonFile: str = None\n):\n    \"\"\"\n    get map of extensions to handle\n\n    Args:\n        extensionNameList(list): a list of extension names\n        extensionJsonFile(str): the name of an extra extensionJsonFile (if any)\n    \"\"\"\n    self.extensionMap = {}\n    extensionList = ExtensionList.restore()\n    if extensionJsonFile is not None:\n        extraExtensionList = ExtensionList.load_from_json_file(extensionJsonFile)\n        for ext in extraExtensionList.extensions:\n            extensionList.extensions.append(ext)\n    self.extByName, duplicates = LOD.getLookup(extensionList.extensions, \"name\")\n    if len(duplicates) &gt; 0:\n        print(f\"{len(duplicates)} duplicate extensions: \")\n        for duplicate in duplicates:\n            print(duplicate.name)\n    if extensionNameList is not None:\n        self.addExtensions(extensionNameList)\n    return self.extensionMap\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.getShortVersion","title":"<code>getShortVersion(separator='')</code>","text":"<p>get my short version e.g. convert 1.27.7 to 127</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the short version string</p> Source code in <code>mwdocker/config.py</code> <pre><code>def getShortVersion(self, separator=\"\"):\n    \"\"\"\n    get my short version e.g. convert 1.27.7 to 127\n\n    Returns:\n        str: the short version string\n    \"\"\"\n    versionMatch = re.match(\"(?P&lt;major&gt;[0-9]+)\\.(?P&lt;minor&gt;[0-9]+)\", self.version)\n    shortVersion = (\n        f\"{versionMatch.group('major')}{separator}{versionMatch.group('minor')}\"\n    )\n    return shortVersion\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.getWikiId","title":"<code>getWikiId()</code>","text":"<p>get the wikiId</p> <p>Returns:</p> Name Type Description <code>str</code> <p>e.g. mw-9080</p> Source code in <code>mwdocker/config.py</code> <pre><code>def getWikiId(self):\n    \"\"\"\n    get the wikiId\n\n    Returns:\n        str: e.g. mw-9080\n    \"\"\"\n    if self.wikiId is None:\n        wikiId = f\"{self.prefix}-{self.port}\"\n    else:\n        wikiId = self.wikiId\n    return wikiId\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.get_config_path","title":"<code>get_config_path()</code>","text":"<p>get my configuration base path</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to my configuration</p> Source code in <code>mwdocker/config.py</code> <pre><code>def get_config_path(self) -&gt; str:\n    \"\"\"\n    get my configuration base path\n\n    Returns:\n        str: the path to my configuration\n    \"\"\"\n    config_base_path = f\"{self.docker_path}/{self.container_base_name}\"\n    os.makedirs(config_base_path, exist_ok=True)\n    path = f\"{config_base_path}/MwConfig.json\"\n    return path\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.load","title":"<code>load(path=None)</code>","text":"<p>load the the MwConfig from the given path of if path is None (default) use the config_path for the current configuration</p> <p>restores the ExtensionMap on load</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to load from</p> required <p>Returns:</p> Name Type Description <code>MwConfig</code> <code>MwConfig</code> <p>a MediaWiki Configuration</p> Source code in <code>mwdocker/config.py</code> <pre><code>def load(self, path: str = None) -&gt; \"MwConfig\":\n    \"\"\"\n    load the the MwConfig from the given path of if path is None (default)\n    use the config_path for the current configuration\n\n    restores the ExtensionMap on load\n\n    Args:\n        path(str): the path to load from\n\n    Returns:\n        MwConfig: a MediaWiki Configuration\n    \"\"\"\n    if path is None:\n        path = self.get_config_path()\n    with open(path, \"r\") as json_file:\n        json_str = json_file.read()\n        config_dict = json.loads(json_str)\n        config = dacite.from_dict(data_class=self.__class__, data=config_dict)\n        # restore extension map\n        config.getExtensionMap(config.extensionNameList, config.extensionJsonFile)\n        return config\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.reset_container_base_name","title":"<code>reset_container_base_name(container_base_name=None)</code>","text":"<p>reset the container base name to the given name</p> <p>Parameters:</p> Name Type Description Default <code>container_base_name(str)</code> <p>the new container base name</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def reset_container_base_name(self, container_base_name: str = None):\n    \"\"\"\n    reset the container base name to the given name\n\n    Args:\n        container_base_name(str): the new container base name\n    \"\"\"\n    self.container_base_name = container_base_name\n    self.__post_init__()\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.reset_url","title":"<code>reset_url(url)</code>","text":"<p>reset my url</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to set</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def reset_url(self, url: str):\n    \"\"\"\n    reset my url\n\n    Args:\n        url(str): the url to set\n    \"\"\"\n    if url:\n        pr = urlparse(url)\n        self.prot = pr.scheme\n        self.host = pr.hostname\n        self.script_path = pr.path\n        self.base_url = f\"{self.prot}://{self.host}\"\n        self.full_url = url\n    else:\n        self.base_url = f\"{self.prot}://{self.host}\"\n        self.full_url = f\"{self.base_url}{self.script_path}:{self.port}\"\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.save","title":"<code>save(path=None)</code>","text":"<p>save my json</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to store to - if None use {docker_path}/{container_base_name}/MwConfig.json</p> required <p>Returns:     str: the path</p> Source code in <code>mwdocker/config.py</code> <pre><code>def save(self, path: str = None) -&gt; str:\n    \"\"\"\n    save my json\n\n    Args:\n        path(str): the path to store to - if None use {docker_path}/{container_base_name}/MwConfig.json\n    Returns:\n        str: the path\n    \"\"\"\n    if path is None:\n        path = self.get_config_path()\n\n    json_str = self.as_json()\n    print(json_str, file=open(path, \"w\"))\n    return path\n</code></pre>"},{"location":"#mwdocker.docker","title":"<code>docker</code>","text":"<p>Created on 2021-08-06</p> <p>@author: wf</p>"},{"location":"#mwdocker.docker.DBStatus","title":"<code>DBStatus</code>  <code>dataclass</code>","text":"<p>the Database Status</p> Source code in <code>mwdocker/docker.py</code> <pre><code>@dataclass\nclass DBStatus:\n    \"\"\"\n    the Database Status\n    \"\"\"\n\n    attempts: int\n    max_tries: int\n    ok: bool\n    msg: str\n    ex: typing.Optional[Exception] = None\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication","title":"<code>DockerApplication</code>","text":"<p>               Bases: <code>object</code></p> <p>MediaWiki Docker image</p> Source code in <code>mwdocker/docker.py</code> <pre><code>class DockerApplication(object):\n    \"\"\"\n    MediaWiki Docker image\n    \"\"\"\n\n    def __init__(self, config: MwClusterConfig):\n        \"\"\"\n        Constructor\n\n        Args:\n            config: MwClusterConfig,\n            home: the home directory to use\n        \"\"\"\n        self.config = config\n        # branch as need for git clone e.g. https://gerrit.wikimedia.org/g/mediawiki/extensions/MagicNoCache\n        self.branch = f\"REL{self.config.getShortVersion('_')}\"\n        self.composerVersion = 1\n        if self.config.shortVersion &gt;= \"139\":\n            self.composerVersion = 2\n        # jinja and docker prerequisites\n        self.env = self.getJinjaEnv()\n        # docker file location\n        self.docker_path = (\n            f\"{self.config.docker_path}/{self.config.container_base_name}\"\n        )\n        os.makedirs(self.docker_path, exist_ok=True)\n\n        self.getContainers()\n        self.dbConn = None\n        self.database = \"wiki\"\n        self.dbUser = \"wikiuser\"\n        self.wikiUser = None\n\n    @staticmethod\n    def checkDockerEnvironment(debug: bool = False) -&gt; str:\n        \"\"\"\n        check the docker environment\n\n        Args:\n            debug(bool): if True show debug information\n\n        Returns:\n            str: an error message or None\n        \"\"\"\n        errMsg = None\n        if not docker.compose.is_installed():\n            errMsg = \"\"\"docker compose up needs to be working\"\"\"\n        os_path = os.environ[\"PATH\"]\n        paths = [\"/usr/local/bin\"]\n        for path in paths:\n            if os.path.islink(f\"{path}/docker\"):\n                if not path in os_path:\n                    os.environ[\"PATH\"] = f\"{os_path}{os.pathsep}{path}\"\n                    if debug:\n                        print(\n                            f\"\"\"modified PATH from {os_path} to \\n{os.environ[\"PATH\"]}\"\"\"\n                        )\n        return errMsg\n\n    def check(self) -&gt; int:\n        \"\"\"\n        check me\n\n        Returns:\n            int: exitCode: 0 if ok, 1 if not ok\n        \"\"\"\n        DockerApplication.checkDockerEnvironment(self.config.debug)\n        exitCode = 0\n        mw, db = self.getContainers()\n        if not mw:\n            print(\"mediawiki container missing\")\n            exitCode = 1\n        if not db:\n            print(\"database container missing\")\n            exitCode = 1\n        if mw and db and mw.check() and db.check():\n            host_port = mw.getHostPort(80)\n            if host_port:\n                Logger.check_and_log_equal(\n                    f\"port binding\", host_port, \"expected  port\", str(self.config.port)\n                )\n                url = self.config.full_url\n                # fix url to local port\n                # @TODO isn't this superfluous / has no effect ...?\n                url = url.replace(str(self.config.port), host_port)\n                version_url = f\"{url}/index.php/Special:Version\"\n\n                ok = self.checkWiki(version_url)\n                if not ok:\n                    exitCode = 1\n            else:\n                self.log(f\"port binding for port 80 missing\", False)\n                exitCode = 1\n            pass\n        return exitCode\n\n    def checkWiki(self, version_url: str) -&gt; bool:\n        \"\"\"\n        check this wiki against the content of the given version_url\n        \"\"\"\n        print(f\"Checking {version_url} ...\")\n        ok = True\n        try:\n            html_tables = HtmlTables(version_url)\n            tables = html_tables.get_tables(\"h2\")\n            if self.config.debug:\n                p = pprint.PrettyPrinter(indent=2)\n                p.pprint(tables)\n            ok = ok and Logger.check_and_log(\n                \"Special Version accessible ...\", \"Installed software\" in tables\n            )\n            if ok:\n                software = tables[\"Installed software\"]\n                software_map, _dup = LOD.getLookup(\n                    software, \"Product\", withDuplicates=False\n                )\n                mw_version = software_map[\"MediaWiki\"][\"Version\"]\n                ok = ok and Logger.check_and_log_equal(\n                    \"Mediawiki Version\", mw_version, \"expected \", self.config.version\n                )\n                db_version_str = software_map[\"MariaDB\"][\"Version\"]\n                db_version = MariaDB.getVersion(db_version_str)\n                ok = ok and Logger.check_and_log(\n                    f\"Maria DB Version {db_version} fitting expected {self.config.mariaDBVersion}?\",\n                    self.config.mariaDBVersion.startswith(db_version),\n                )\n                pass\n        except Exception as ex:\n            ok = Logger.check_and_log(str(ex), False)\n        return ok\n\n    def getContainerName(self, kind: str, separator: str):\n        \"\"\"\n        get my container Name\n        \"\"\"\n        containerName = f\"{self.config.container_base_name}{separator}{kind}\"\n        return containerName\n\n    def getContainers(self):\n        \"\"\"\n        get my containers\n\n        Returns:\n            Tuple(\n        \"\"\"\n        self.dbContainer = None\n        self.mwContainer = None\n        containerMap = DockerMap.getContainerMap()\n        for separator in [\"-\", \"_\"]:\n            dbContainerName = self.getContainerName(\"db\", separator)\n            mwContainerName = self.getContainerName(\"mw\", separator)\n            if dbContainerName in containerMap:\n                self.dbContainer = DockerContainer(\n                    dbContainerName, \"database\", containerMap[dbContainerName]\n                )\n            if mwContainerName in containerMap:\n                self.mwContainer = DockerContainer(\n                    mwContainerName, \"webserver\", containerMap[mwContainerName]\n                )\n        return self.mwContainer, self.dbContainer\n\n    def getJinjaEnv(self):\n        \"\"\"\n        get a Jinja2 environment\n        \"\"\"\n        scriptdir = os.path.dirname(os.path.realpath(__file__))\n        resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n        template_dir = os.path.realpath(f\"{resourcePath}/templates\")\n        # print(f\"jinja template directory is {template_dir}\")\n        env = Environment(loader=FileSystemLoader(template_dir))\n        return env\n\n    def initDB(self):\n        \"\"\"\n        initialize my SQL database\n        \"\"\"\n        # restore the mySQL dump data\n        self.execute(\"/root/initdb.sh\")\n        # update the database e.g. to initialize Semantic MediaWiki tables\n        self.execute(\"/root/update.sh\")\n        # add an initial sysop user as specified\n        self.execute(\"/root/addSysopUser.sh\")\n\n    def installExtensions(self):\n        \"\"\"\n        install all extensions\n        \"\"\"\n        self.execute(\"/root/installExtensions.sh\")\n        self.execute(\"/root/fixPermissions.sh\")\n\n    def startUp(self):\n        \"\"\"\n        run startUp scripts\n        \"\"\"\n        # fix permissions\n        self.execute(\"/root/fixPermissions.sh\")\n        # add language icons\n        self.execute(\"/root/lang.sh\", \"--site\", \"/var/www/html\")\n        # start cron job\n        self.execute(\"/root/addCronTabEntry.sh\")\n\n    def createWikiUser(self, wikiId: str = None, store: bool = False):\n        \"\"\"\n        create my wikiUser and optionally save it\n\n        Args:\n           store(bool): if True save my user data to the relevant ini File\n        \"\"\"\n        if not wikiId:\n            wikiId = f\"{self.config.container_base_name}\"\n        userDict = {\n            \"wikiId\": f\"{wikiId}\",\n            \"url\": f\"{self.config.base_url}:{self.config.port}\",\n            \"scriptPath\": f\"{self.config.script_path}\",\n            \"user\": f\"{self.config.user}\",\n            \"email\": \"noreply@nouser.com\",\n            \"version\": f\"{self.config.fullVersion}\",\n            \"password\": f\"{self.config.password}\",\n        }\n        wikiUser = WikiUser.ofDict(userDict, encrypted=False)\n        if store:\n            wikiUser.save()\n        return wikiUser\n\n    def createOrModifyWikiUser(self, wikiId, force_overwrite: bool = False) -&gt; WikiUser:\n        \"\"\"\n        create or modify the WikiUser for this DockerApplication\n\n        Args:\n            wikiId(str): the wikiId to create or modify a wiki user for\n            force_overwrite(bool): if True overwrite the wikiuser info\n        \"\"\"\n        wikiUsers = WikiUser.getWikiUsers(lenient=True)\n        if wikiId in wikiUsers and not force_overwrite:\n            wikiUser = wikiUsers[wikiId]\n            if self.config.password != wikiUser.getPassword():\n                raise Exception(\n                    f\"wikiUser for wiki {wikiId} already exists but with different password\"\n                )\n            pass\n        else:\n            wikiUser = self.createWikiUser(wikiId, store=True)\n        return wikiUser\n\n    def execute(self, *commands: str):\n        \"\"\"\n        execute the given variable list of command strings\n\n        Args:\n            commands: str - the command strings to be executed ...\n        \"\"\"\n        command_list = list(commands)\n        if self.mwContainer:\n            if self.config.verbose:\n                command_line = \" \".join(command_list)\n                print(f\"Executing docker command {command_line}\")\n            docker.execute(container=self.mwContainer.container, command=command_list)\n        else:\n            mwContainerNameDash = self.getContainerName(\"mw\", \"-\")\n            mwContainerNameUnderscore = self.getContainerName(\"mw\", \"_\")\n            errMsg = f\"no mediawiki Container {mwContainerNameDash} or {mwContainerNameUnderscore} for {self.name} activated by docker compose\\n- you might want to check the separator character used for container names for your platform {platform.system()}\"\n            raise Exception(f\"{errMsg}\")\n\n    def close(self):\n        \"\"\"\n        close the database\n        \"\"\"\n        self.dbClose()\n\n    def sqlQuery(self, query):\n        \"\"\"\n        run the given SQL query\n        \"\"\"\n        if self.dbConn and self.dbConn.is_connected():\n            cursor = self.dbConn.cursor()\n            cursor.execute(query)\n            rows = cursor.fetchall()\n            cursor.close()\n            return rows\n        else:\n            if self.config.verbose:\n                print(\n                    f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} not established\"\n                )\n            return None\n\n    def dbClose(self):\n        \"\"\"\n        close the database connection\n        \"\"\"\n        if self.dbConn and self.dbConn.is_connected():\n            self.dbConn.close()\n\n    def dbConnect(self, timeout: int = 10):\n        \"\"\"\n        connect to the database and return the connection\n\n        Args:\n            timeout(int): number of seconds for timeout\n\n        Returns:\n            the connection\n        \"\"\"\n        if self.dbConn is None:\n            try:\n                self.dbConn = mysql.connector.connect(\n                    host=self.config.host,\n                    database=self.database,\n                    user=self.dbUser,\n                    port=self.config.sql_port,\n                    password=self.config.mySQLPassword,\n                    connection_timeout=timeout,\n                )\n\n            except Error as e:\n                errMsg = str(e)\n                print(\n                    f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} failed error: {errMsg}\"\n                )\n                if \"Access denied\" in errMsg:\n                    raise e\n        return self.dbConn\n\n    def doCheckDBConnection(self, dbStatus: DBStatus, timeout: int = 10):\n        \"\"\"\n        check the database connection of this application\n\n        Args:\n            timeout(int): how many seconds to wait\n\n        Returns:\n            DBStatus\n        \"\"\"\n        dbStatus.attempts += 1\n        self.dbConnect(timeout=timeout)\n        if self.dbConn and self.dbConn.is_connected():\n            rows = self.sqlQuery(\"select database();\")\n            dbStatus.ok = True\n            if self.config.verbose:\n                print(f\"{dbStatus.msg} established database returns: {rows[0]}\")\n\n    def checkDBConnection(\n        self,\n        timeout: float = 10,\n        initialSleep: float = 4.0,\n        factor=1.5,\n        maxTries: int = 9,\n    ) -&gt; DBStatus:\n        \"\"\"\n        check database connection with retries\n\n        Args:\n            timeout(float): number of seconds for timeout\n            initialSleep(float): number of seconds to initially wait/sleep\n            maxTries(int): maximum number of retries before giving up between each try a sleep is done that starts\n            with 0.5 secs and multiplies on every retry\n\n        Returns:\n            dbStatus: the status\n        \"\"\"\n        conn_msg = f\"SQL-Connection to {self.database} on {self.config.host} port {self.config.sql_port} with user {self.dbUser}\"\n        dbStatus = DBStatus(attempts=0, ok=False, msg=conn_msg, max_tries=maxTries)\n        if self.config.verbose:\n            print(\n                f\"Trying {dbStatus.msg} with max {maxTries} tries and {timeout}s timeout per try - initial sleep {initialSleep}s\"\n            )\n        time.sleep(initialSleep)\n        sleep = 2.0\n        while not dbStatus.ok and dbStatus.attempts &lt;= maxTries:\n            try:\n                self.doCheckDBConnection(dbStatus, timeout=timeout)\n                if not dbStatus.ok:\n                    if self.config.verbose:\n                        print(\n                            f\"Connection attempt #{dbStatus.attempts}/{dbStatus.max_tries} failed will retry in {sleep:4.1f} secs\"\n                        )\n                    # wait before trying\n                    time.sleep(sleep)\n                    sleep = sleep * factor\n            except Exception as ex:\n                dbStatus.ex = ex\n                if self.config.verbose:\n                    print(\n                        f\"Connection attempt #{dbStatus.attempts} failed with exception {str(ex)} - will not retry ...\"\n                    )\n                if self.config.debug:\n                    print(traceback.format_exc())\n                break\n        return dbStatus\n\n    def optionalWrite(self, targetPath: str, content: str, overwrite: bool = False):\n        \"\"\"\n        optionally Write the modified content to the given targetPath\n\n        Args:\n            targetPath(str): the path to write the content to\n            content(str): the content to write\n            overwrite(bool): if True overwrite the existing content\n        \"\"\"\n        if not overwrite and os.path.isfile(targetPath):\n            if self.config.verbose:\n                print(f\"{targetPath} already exists!\")\n            return\n        with open(targetPath, \"w\") as targetFile:\n            targetFile.write(content)\n\n    def generate(\n        self, templateName: str, targetPath: str, overwrite: bool = False, **kwArgs\n    ):\n        \"\"\"\n        generate file at targetPath using the given templateName\n\n        Args:\n            templateName(str): the Jinja2 template to use\n            targetPath(str): the path to the target file\n            overwrite(bool): if True overwrite existing files\n            kwArgs(): generic keyword arguments to pass on to template rendering\n        \"\"\"\n        try:\n            template = self.env.get_template(templateName)\n            timestamp = datetime.datetime.now().isoformat()\n            content = template.render(\n                mwVersion=self.config.version,\n                mariaDBVersion=self.config.mariaDBVersion,\n                port=self.config.port,\n                sql_port=self.config.sql_port,\n                smw_version=self.config.smw_version,\n                timestamp=timestamp,\n                **kwArgs,\n            )\n            self.optionalWrite(targetPath, content, overwrite)\n\n        except TemplateNotFound:\n            print(\n                f\"no template {templateName} for {self.config.name} {self.config.version}\"\n            )\n\n    def getComposerRequire(self):\n        \"\"\"\n        get the json string for the composer require e.g. composer.local.json\n        \"\"\"\n        requires = []\n        for ext in self.config.extensionMap.values():\n            # get the composer statement\n            if ext.composer:\n                requires.append(ext.composer)\n        indent = \"     \"\n        delim = \"\" if len(requires) == 0 else \",\\n\"\n        requireList = \"\"\n        if self.config.smw_version:\n            requireList += f'{indent}\"mediawiki/semantic-media-wiki\": \"~{self.config.smw_version}\"{delim}'\n        for i, require in enumerate(requires):\n            delim = \"\" if i &gt;= len(requires) - 1 else \",\\n\"\n            requireList += f\"{indent}{require}{delim}\"\n        requireJson = f\"\"\"{{   \n  \"require\": {{\n{requireList} \n  }} \n}}\"\"\"\n        return requireJson\n\n    def genComposerRequire(self, composerFilePath, overwrite: bool = False):\n        \"\"\"\n        gen the composer.local.json require file\n\n        Args:\n            composerFilePath(str): the name of the file to generate\n        \"\"\"\n        requireJson = self.getComposerRequire()\n        self.optionalWrite(composerFilePath, requireJson, overwrite)\n\n    def generateAll(self, overwrite: bool = False):\n        \"\"\"\n        generate all files needed for the docker handling\n\n        Args:\n            overwrite(bool): if True overwrite the existing files\n        \"\"\"\n        # then generate\n        self.generate(\n            \"mwDockerfile\",\n            f\"{self.docker_path}/Dockerfile\",\n            composerVersion=self.composerVersion,\n            overwrite=overwrite,\n        )\n        self.generate(\n            \"mwCompose.yml\",\n            f\"{self.docker_path}/docker-compose.yml\",\n            mySQLRootPassword=self.config.mySQLRootPassword,\n            mySQLPassword=self.config.mySQLPassword,\n            container_base_name=self.config.container_base_name,\n            overwrite=overwrite,\n        )\n        self.generate(\n            f\"mwLocalSettings{self.config.shortVersion}.php\",\n            f\"{self.docker_path}/LocalSettings.php\",\n            mySQLPassword=self.config.mySQLPassword,\n            hostname=self.config.host,\n            extensions=self.config.extensionMap.values(),\n            mwShortVersion=self.config.shortVersion,\n            logo=self.config.logo,\n            overwrite=overwrite,\n        )\n        self.generate(\n            f\"mwWiki{self.config.shortVersion}.sql\",\n            f\"{self.docker_path}/wiki.sql\",\n            overwrite=overwrite,\n        )\n        if self.config.random_password:\n            self.config.password = self.config.create_random_password(\n                length=self.config.password_length\n            )\n            if self.config.wikiId:\n                self.createOrModifyWikiUser(\n                    self.config.wikiId, force_overwrite=self.config.force_user\n                )\n        self.generate(\n            f\"addSysopUser.sh\",\n            f\"{self.docker_path}/addSysopUser.sh\",\n            user=self.config.user,\n            password=self.config.password,\n            overwrite=overwrite,\n        )\n        self.generate(\n            f\"installExtensions.sh\",\n            f\"{self.docker_path}/installExtensions.sh\",\n            extensions=self.config.extensionMap.values(),\n            branch=self.branch,\n            overwrite=overwrite,\n        )\n        self.genComposerRequire(\n            f\"{self.docker_path}/composer.local.json\", overwrite=overwrite\n        )\n        for file_name in [\n            \"addCronTabEntry.sh\",\n            \"fixPermissions.sh\",\n            \"initdb.sh\",\n            \"lang.sh\",\n            \"phpinfo.php\",\n            \"install_djvu.sh\",\n            \"plantuml.sh\",\n            \"startRunJobs.sh\",\n            \"upload.ini\",\n            \"update.sh\",\n        ]:\n            self.generate(\n                f\"{file_name}\", f\"{self.docker_path}/{file_name}\", overwrite=overwrite\n            )\n        # remember the configuration we used for generating\n        # avoid endless loop - forceRebuilds - we have rebuild already\n        forceRebuild = self.config.forceRebuild\n        self.config.forceRebuild = False\n        self.config.save()\n        self.config.forceRebuild = forceRebuild\n\n    def down(self, forceRebuild: bool = False):\n        \"\"\"\n        run docker compose down\n\n        see https://docs.docker.com/engine/reference/commandline/compose_down/\n        and https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/compose/#down\n\n        \"\"\"\n        DockerApplication.checkDockerEnvironment(self.config.debug)\n        # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n        if self.config.verbose:\n            print(\n                f\"running docker compose down for {self.config.container_base_name} {self.config.version} docker application ...\"\n            )\n        # remember current directory\n        cwd = os.getcwd()\n        os.chdir(self.docker_path)\n        docker.compose.down(volumes=forceRebuild)\n        # switch back to previous current directory\n        os.chdir(cwd)\n\n    def up(self, forceRebuild: bool = False):\n        \"\"\"\n        start this docker application\n\n        Args:\n            forceRebuild(bool): if true stop and remove the existing containers\n        \"\"\"\n        DockerApplication.checkDockerEnvironment(self.config.debug)\n        if self.config.verbose:\n            print(\n                f\"starting {self.config.container_base_name} {self.config.version} docker application ...\"\n            )\n        if forceRebuild:\n            for docker_container in [self.dbContainer, self.mwContainer]:\n                if docker_container is not None:\n                    container = docker_container.container\n                    try:\n                        container_name = container.name\n                        if self.config.verbose:\n                            print(f\"stopping and removing container {container_name}\")\n                    except Exception as container_ex:\n                        container = None\n                    if container:\n                        try:\n                            container.stop()\n                        except Exception as stop_ex:\n                            if self.config.verbose:\n                                print(f\"stop failed with {str(stop_ex)}\")\n                            pass\n                        try:\n                            container.remove()\n                        except Exception as remove_ex:\n                            if self.config.verbose:\n                                print(f\"removed failed with {str(remove_ex)}\")\n                            pass\n                    pass\n\n        # remember current directory\n        cwd = os.getcwd()\n\n        # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n        os.chdir(self.docker_path)\n        # project_config = docker.compose.config()\n        if forceRebuild:\n            docker.compose.build()\n        # run docker compose up\n        # this might take a while e.g. downloading\n        # run docker compose up\n        try:\n            docker.compose.up(detach=True, force_recreate=forceRebuild)\n        except Exception as de:\n            print(f\"docker compose up failed in {self.docker_path}\")\n            raise de\n            pass\n        # switch back to previous current directory\n        os.chdir(cwd)\n\n        return self.getContainers()\n\n    def start(self, forceRebuild: bool = False, withInitDB=True):\n        \"\"\"\n        start my containers\n\n        Args:\n            forceRebuild(bool): if True force rebuilding\n            withInitDB(bool): if True intialize my database\n        \"\"\"\n        self.up(forceRebuild=forceRebuild)\n        if withInitDB:\n            if self.config.verbose:\n                print(\"Initializing MediaWiki SQL tables ...\")\n            dbStatus = self.checkDBConnection()\n            if dbStatus.ok:\n                # first install extensions\n                self.installExtensions()\n                # then create and fill database and update it\n                self.initDB()\n                # then run startUp scripts\n                self.startUp()\n        if self.config.verbose:\n            print(\n                f\"MediaWiki {self.config.container_base_name} is ready at {self.config.full_url}\"\n            )\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.__init__","title":"<code>__init__(config)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MwClusterConfig</code> <p>MwClusterConfig,</p> required <code>home</code> <p>the home directory to use</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def __init__(self, config: MwClusterConfig):\n    \"\"\"\n    Constructor\n\n    Args:\n        config: MwClusterConfig,\n        home: the home directory to use\n    \"\"\"\n    self.config = config\n    # branch as need for git clone e.g. https://gerrit.wikimedia.org/g/mediawiki/extensions/MagicNoCache\n    self.branch = f\"REL{self.config.getShortVersion('_')}\"\n    self.composerVersion = 1\n    if self.config.shortVersion &gt;= \"139\":\n        self.composerVersion = 2\n    # jinja and docker prerequisites\n    self.env = self.getJinjaEnv()\n    # docker file location\n    self.docker_path = (\n        f\"{self.config.docker_path}/{self.config.container_base_name}\"\n    )\n    os.makedirs(self.docker_path, exist_ok=True)\n\n    self.getContainers()\n    self.dbConn = None\n    self.database = \"wiki\"\n    self.dbUser = \"wikiuser\"\n    self.wikiUser = None\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.check","title":"<code>check()</code>","text":"<p>check me</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode: 0 if ok, 1 if not ok</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def check(self) -&gt; int:\n    \"\"\"\n    check me\n\n    Returns:\n        int: exitCode: 0 if ok, 1 if not ok\n    \"\"\"\n    DockerApplication.checkDockerEnvironment(self.config.debug)\n    exitCode = 0\n    mw, db = self.getContainers()\n    if not mw:\n        print(\"mediawiki container missing\")\n        exitCode = 1\n    if not db:\n        print(\"database container missing\")\n        exitCode = 1\n    if mw and db and mw.check() and db.check():\n        host_port = mw.getHostPort(80)\n        if host_port:\n            Logger.check_and_log_equal(\n                f\"port binding\", host_port, \"expected  port\", str(self.config.port)\n            )\n            url = self.config.full_url\n            # fix url to local port\n            # @TODO isn't this superfluous / has no effect ...?\n            url = url.replace(str(self.config.port), host_port)\n            version_url = f\"{url}/index.php/Special:Version\"\n\n            ok = self.checkWiki(version_url)\n            if not ok:\n                exitCode = 1\n        else:\n            self.log(f\"port binding for port 80 missing\", False)\n            exitCode = 1\n        pass\n    return exitCode\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.checkDBConnection","title":"<code>checkDBConnection(timeout=10, initialSleep=4.0, factor=1.5, maxTries=9)</code>","text":"<p>check database connection with retries</p> <p>Parameters:</p> Name Type Description Default <code>timeout(float)</code> <p>number of seconds for timeout</p> required <code>initialSleep(float)</code> <p>number of seconds to initially wait/sleep</p> required <code>maxTries(int)</code> <p>maximum number of retries before giving up between each try a sleep is done that starts</p> required <p>Returns:</p> Name Type Description <code>dbStatus</code> <code>DBStatus</code> <p>the status</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def checkDBConnection(\n    self,\n    timeout: float = 10,\n    initialSleep: float = 4.0,\n    factor=1.5,\n    maxTries: int = 9,\n) -&gt; DBStatus:\n    \"\"\"\n    check database connection with retries\n\n    Args:\n        timeout(float): number of seconds for timeout\n        initialSleep(float): number of seconds to initially wait/sleep\n        maxTries(int): maximum number of retries before giving up between each try a sleep is done that starts\n        with 0.5 secs and multiplies on every retry\n\n    Returns:\n        dbStatus: the status\n    \"\"\"\n    conn_msg = f\"SQL-Connection to {self.database} on {self.config.host} port {self.config.sql_port} with user {self.dbUser}\"\n    dbStatus = DBStatus(attempts=0, ok=False, msg=conn_msg, max_tries=maxTries)\n    if self.config.verbose:\n        print(\n            f\"Trying {dbStatus.msg} with max {maxTries} tries and {timeout}s timeout per try - initial sleep {initialSleep}s\"\n        )\n    time.sleep(initialSleep)\n    sleep = 2.0\n    while not dbStatus.ok and dbStatus.attempts &lt;= maxTries:\n        try:\n            self.doCheckDBConnection(dbStatus, timeout=timeout)\n            if not dbStatus.ok:\n                if self.config.verbose:\n                    print(\n                        f\"Connection attempt #{dbStatus.attempts}/{dbStatus.max_tries} failed will retry in {sleep:4.1f} secs\"\n                    )\n                # wait before trying\n                time.sleep(sleep)\n                sleep = sleep * factor\n        except Exception as ex:\n            dbStatus.ex = ex\n            if self.config.verbose:\n                print(\n                    f\"Connection attempt #{dbStatus.attempts} failed with exception {str(ex)} - will not retry ...\"\n                )\n            if self.config.debug:\n                print(traceback.format_exc())\n            break\n    return dbStatus\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.checkDockerEnvironment","title":"<code>checkDockerEnvironment(debug=False)</code>  <code>staticmethod</code>","text":"<p>check the docker environment</p> <p>Parameters:</p> Name Type Description Default <code>debug(bool)</code> <p>if True show debug information</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>an error message or None</p> Source code in <code>mwdocker/docker.py</code> <pre><code>@staticmethod\ndef checkDockerEnvironment(debug: bool = False) -&gt; str:\n    \"\"\"\n    check the docker environment\n\n    Args:\n        debug(bool): if True show debug information\n\n    Returns:\n        str: an error message or None\n    \"\"\"\n    errMsg = None\n    if not docker.compose.is_installed():\n        errMsg = \"\"\"docker compose up needs to be working\"\"\"\n    os_path = os.environ[\"PATH\"]\n    paths = [\"/usr/local/bin\"]\n    for path in paths:\n        if os.path.islink(f\"{path}/docker\"):\n            if not path in os_path:\n                os.environ[\"PATH\"] = f\"{os_path}{os.pathsep}{path}\"\n                if debug:\n                    print(\n                        f\"\"\"modified PATH from {os_path} to \\n{os.environ[\"PATH\"]}\"\"\"\n                    )\n    return errMsg\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.checkWiki","title":"<code>checkWiki(version_url)</code>","text":"<p>check this wiki against the content of the given version_url</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def checkWiki(self, version_url: str) -&gt; bool:\n    \"\"\"\n    check this wiki against the content of the given version_url\n    \"\"\"\n    print(f\"Checking {version_url} ...\")\n    ok = True\n    try:\n        html_tables = HtmlTables(version_url)\n        tables = html_tables.get_tables(\"h2\")\n        if self.config.debug:\n            p = pprint.PrettyPrinter(indent=2)\n            p.pprint(tables)\n        ok = ok and Logger.check_and_log(\n            \"Special Version accessible ...\", \"Installed software\" in tables\n        )\n        if ok:\n            software = tables[\"Installed software\"]\n            software_map, _dup = LOD.getLookup(\n                software, \"Product\", withDuplicates=False\n            )\n            mw_version = software_map[\"MediaWiki\"][\"Version\"]\n            ok = ok and Logger.check_and_log_equal(\n                \"Mediawiki Version\", mw_version, \"expected \", self.config.version\n            )\n            db_version_str = software_map[\"MariaDB\"][\"Version\"]\n            db_version = MariaDB.getVersion(db_version_str)\n            ok = ok and Logger.check_and_log(\n                f\"Maria DB Version {db_version} fitting expected {self.config.mariaDBVersion}?\",\n                self.config.mariaDBVersion.startswith(db_version),\n            )\n            pass\n    except Exception as ex:\n        ok = Logger.check_and_log(str(ex), False)\n    return ok\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.close","title":"<code>close()</code>","text":"<p>close the database</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def close(self):\n    \"\"\"\n    close the database\n    \"\"\"\n    self.dbClose()\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.createOrModifyWikiUser","title":"<code>createOrModifyWikiUser(wikiId, force_overwrite=False)</code>","text":"<p>create or modify the WikiUser for this DockerApplication</p> <p>Parameters:</p> Name Type Description Default <code>wikiId(str)</code> <p>the wikiId to create or modify a wiki user for</p> required <code>force_overwrite(bool)</code> <p>if True overwrite the wikiuser info</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def createOrModifyWikiUser(self, wikiId, force_overwrite: bool = False) -&gt; WikiUser:\n    \"\"\"\n    create or modify the WikiUser for this DockerApplication\n\n    Args:\n        wikiId(str): the wikiId to create or modify a wiki user for\n        force_overwrite(bool): if True overwrite the wikiuser info\n    \"\"\"\n    wikiUsers = WikiUser.getWikiUsers(lenient=True)\n    if wikiId in wikiUsers and not force_overwrite:\n        wikiUser = wikiUsers[wikiId]\n        if self.config.password != wikiUser.getPassword():\n            raise Exception(\n                f\"wikiUser for wiki {wikiId} already exists but with different password\"\n            )\n        pass\n    else:\n        wikiUser = self.createWikiUser(wikiId, store=True)\n    return wikiUser\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.createWikiUser","title":"<code>createWikiUser(wikiId=None, store=False)</code>","text":"<p>create my wikiUser and optionally save it</p> <p>Parameters:</p> Name Type Description Default <code>store(bool)</code> <p>if True save my user data to the relevant ini File</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def createWikiUser(self, wikiId: str = None, store: bool = False):\n    \"\"\"\n    create my wikiUser and optionally save it\n\n    Args:\n       store(bool): if True save my user data to the relevant ini File\n    \"\"\"\n    if not wikiId:\n        wikiId = f\"{self.config.container_base_name}\"\n    userDict = {\n        \"wikiId\": f\"{wikiId}\",\n        \"url\": f\"{self.config.base_url}:{self.config.port}\",\n        \"scriptPath\": f\"{self.config.script_path}\",\n        \"user\": f\"{self.config.user}\",\n        \"email\": \"noreply@nouser.com\",\n        \"version\": f\"{self.config.fullVersion}\",\n        \"password\": f\"{self.config.password}\",\n    }\n    wikiUser = WikiUser.ofDict(userDict, encrypted=False)\n    if store:\n        wikiUser.save()\n    return wikiUser\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.dbClose","title":"<code>dbClose()</code>","text":"<p>close the database connection</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def dbClose(self):\n    \"\"\"\n    close the database connection\n    \"\"\"\n    if self.dbConn and self.dbConn.is_connected():\n        self.dbConn.close()\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.dbConnect","title":"<code>dbConnect(timeout=10)</code>","text":"<p>connect to the database and return the connection</p> <p>Parameters:</p> Name Type Description Default <code>timeout(int)</code> <p>number of seconds for timeout</p> required <p>Returns:</p> Type Description <p>the connection</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def dbConnect(self, timeout: int = 10):\n    \"\"\"\n    connect to the database and return the connection\n\n    Args:\n        timeout(int): number of seconds for timeout\n\n    Returns:\n        the connection\n    \"\"\"\n    if self.dbConn is None:\n        try:\n            self.dbConn = mysql.connector.connect(\n                host=self.config.host,\n                database=self.database,\n                user=self.dbUser,\n                port=self.config.sql_port,\n                password=self.config.mySQLPassword,\n                connection_timeout=timeout,\n            )\n\n        except Error as e:\n            errMsg = str(e)\n            print(\n                f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} failed error: {errMsg}\"\n            )\n            if \"Access denied\" in errMsg:\n                raise e\n    return self.dbConn\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.doCheckDBConnection","title":"<code>doCheckDBConnection(dbStatus, timeout=10)</code>","text":"<p>check the database connection of this application</p> <p>Parameters:</p> Name Type Description Default <code>timeout(int)</code> <p>how many seconds to wait</p> required <p>Returns:</p> Type Description <p>DBStatus</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def doCheckDBConnection(self, dbStatus: DBStatus, timeout: int = 10):\n    \"\"\"\n    check the database connection of this application\n\n    Args:\n        timeout(int): how many seconds to wait\n\n    Returns:\n        DBStatus\n    \"\"\"\n    dbStatus.attempts += 1\n    self.dbConnect(timeout=timeout)\n    if self.dbConn and self.dbConn.is_connected():\n        rows = self.sqlQuery(\"select database();\")\n        dbStatus.ok = True\n        if self.config.verbose:\n            print(f\"{dbStatus.msg} established database returns: {rows[0]}\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.down","title":"<code>down(forceRebuild=False)</code>","text":"<p>run docker compose down</p> <p>see https://docs.docker.com/engine/reference/commandline/compose_down/ and https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/compose/#down</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def down(self, forceRebuild: bool = False):\n    \"\"\"\n    run docker compose down\n\n    see https://docs.docker.com/engine/reference/commandline/compose_down/\n    and https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/compose/#down\n\n    \"\"\"\n    DockerApplication.checkDockerEnvironment(self.config.debug)\n    # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n    if self.config.verbose:\n        print(\n            f\"running docker compose down for {self.config.container_base_name} {self.config.version} docker application ...\"\n        )\n    # remember current directory\n    cwd = os.getcwd()\n    os.chdir(self.docker_path)\n    docker.compose.down(volumes=forceRebuild)\n    # switch back to previous current directory\n    os.chdir(cwd)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.execute","title":"<code>execute(*commands)</code>","text":"<p>execute the given variable list of command strings</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>str</code> <p>str - the command strings to be executed ...</p> <code>()</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def execute(self, *commands: str):\n    \"\"\"\n    execute the given variable list of command strings\n\n    Args:\n        commands: str - the command strings to be executed ...\n    \"\"\"\n    command_list = list(commands)\n    if self.mwContainer:\n        if self.config.verbose:\n            command_line = \" \".join(command_list)\n            print(f\"Executing docker command {command_line}\")\n        docker.execute(container=self.mwContainer.container, command=command_list)\n    else:\n        mwContainerNameDash = self.getContainerName(\"mw\", \"-\")\n        mwContainerNameUnderscore = self.getContainerName(\"mw\", \"_\")\n        errMsg = f\"no mediawiki Container {mwContainerNameDash} or {mwContainerNameUnderscore} for {self.name} activated by docker compose\\n- you might want to check the separator character used for container names for your platform {platform.system()}\"\n        raise Exception(f\"{errMsg}\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.genComposerRequire","title":"<code>genComposerRequire(composerFilePath, overwrite=False)</code>","text":"<p>gen the composer.local.json require file</p> <p>Parameters:</p> Name Type Description Default <code>composerFilePath(str)</code> <p>the name of the file to generate</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def genComposerRequire(self, composerFilePath, overwrite: bool = False):\n    \"\"\"\n    gen the composer.local.json require file\n\n    Args:\n        composerFilePath(str): the name of the file to generate\n    \"\"\"\n    requireJson = self.getComposerRequire()\n    self.optionalWrite(composerFilePath, requireJson, overwrite)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.generate","title":"<code>generate(templateName, targetPath, overwrite=False, **kwArgs)</code>","text":"<p>generate file at targetPath using the given templateName</p> <p>Parameters:</p> Name Type Description Default <code>templateName(str)</code> <p>the Jinja2 template to use</p> required <code>targetPath(str)</code> <p>the path to the target file</p> required <code>overwrite(bool)</code> <p>if True overwrite existing files</p> required <code>kwArgs()</code> <p>generic keyword arguments to pass on to template rendering</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def generate(\n    self, templateName: str, targetPath: str, overwrite: bool = False, **kwArgs\n):\n    \"\"\"\n    generate file at targetPath using the given templateName\n\n    Args:\n        templateName(str): the Jinja2 template to use\n        targetPath(str): the path to the target file\n        overwrite(bool): if True overwrite existing files\n        kwArgs(): generic keyword arguments to pass on to template rendering\n    \"\"\"\n    try:\n        template = self.env.get_template(templateName)\n        timestamp = datetime.datetime.now().isoformat()\n        content = template.render(\n            mwVersion=self.config.version,\n            mariaDBVersion=self.config.mariaDBVersion,\n            port=self.config.port,\n            sql_port=self.config.sql_port,\n            smw_version=self.config.smw_version,\n            timestamp=timestamp,\n            **kwArgs,\n        )\n        self.optionalWrite(targetPath, content, overwrite)\n\n    except TemplateNotFound:\n        print(\n            f\"no template {templateName} for {self.config.name} {self.config.version}\"\n        )\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.generateAll","title":"<code>generateAll(overwrite=False)</code>","text":"<p>generate all files needed for the docker handling</p> <p>Parameters:</p> Name Type Description Default <code>overwrite(bool)</code> <p>if True overwrite the existing files</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def generateAll(self, overwrite: bool = False):\n    \"\"\"\n    generate all files needed for the docker handling\n\n    Args:\n        overwrite(bool): if True overwrite the existing files\n    \"\"\"\n    # then generate\n    self.generate(\n        \"mwDockerfile\",\n        f\"{self.docker_path}/Dockerfile\",\n        composerVersion=self.composerVersion,\n        overwrite=overwrite,\n    )\n    self.generate(\n        \"mwCompose.yml\",\n        f\"{self.docker_path}/docker-compose.yml\",\n        mySQLRootPassword=self.config.mySQLRootPassword,\n        mySQLPassword=self.config.mySQLPassword,\n        container_base_name=self.config.container_base_name,\n        overwrite=overwrite,\n    )\n    self.generate(\n        f\"mwLocalSettings{self.config.shortVersion}.php\",\n        f\"{self.docker_path}/LocalSettings.php\",\n        mySQLPassword=self.config.mySQLPassword,\n        hostname=self.config.host,\n        extensions=self.config.extensionMap.values(),\n        mwShortVersion=self.config.shortVersion,\n        logo=self.config.logo,\n        overwrite=overwrite,\n    )\n    self.generate(\n        f\"mwWiki{self.config.shortVersion}.sql\",\n        f\"{self.docker_path}/wiki.sql\",\n        overwrite=overwrite,\n    )\n    if self.config.random_password:\n        self.config.password = self.config.create_random_password(\n            length=self.config.password_length\n        )\n        if self.config.wikiId:\n            self.createOrModifyWikiUser(\n                self.config.wikiId, force_overwrite=self.config.force_user\n            )\n    self.generate(\n        f\"addSysopUser.sh\",\n        f\"{self.docker_path}/addSysopUser.sh\",\n        user=self.config.user,\n        password=self.config.password,\n        overwrite=overwrite,\n    )\n    self.generate(\n        f\"installExtensions.sh\",\n        f\"{self.docker_path}/installExtensions.sh\",\n        extensions=self.config.extensionMap.values(),\n        branch=self.branch,\n        overwrite=overwrite,\n    )\n    self.genComposerRequire(\n        f\"{self.docker_path}/composer.local.json\", overwrite=overwrite\n    )\n    for file_name in [\n        \"addCronTabEntry.sh\",\n        \"fixPermissions.sh\",\n        \"initdb.sh\",\n        \"lang.sh\",\n        \"phpinfo.php\",\n        \"install_djvu.sh\",\n        \"plantuml.sh\",\n        \"startRunJobs.sh\",\n        \"upload.ini\",\n        \"update.sh\",\n    ]:\n        self.generate(\n            f\"{file_name}\", f\"{self.docker_path}/{file_name}\", overwrite=overwrite\n        )\n    # remember the configuration we used for generating\n    # avoid endless loop - forceRebuilds - we have rebuild already\n    forceRebuild = self.config.forceRebuild\n    self.config.forceRebuild = False\n    self.config.save()\n    self.config.forceRebuild = forceRebuild\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getComposerRequire","title":"<code>getComposerRequire()</code>","text":"<p>get the json string for the composer require e.g. composer.local.json</p> Source code in <code>mwdocker/docker.py</code> <pre><code>    def getComposerRequire(self):\n        \"\"\"\n        get the json string for the composer require e.g. composer.local.json\n        \"\"\"\n        requires = []\n        for ext in self.config.extensionMap.values():\n            # get the composer statement\n            if ext.composer:\n                requires.append(ext.composer)\n        indent = \"     \"\n        delim = \"\" if len(requires) == 0 else \",\\n\"\n        requireList = \"\"\n        if self.config.smw_version:\n            requireList += f'{indent}\"mediawiki/semantic-media-wiki\": \"~{self.config.smw_version}\"{delim}'\n        for i, require in enumerate(requires):\n            delim = \"\" if i &gt;= len(requires) - 1 else \",\\n\"\n            requireList += f\"{indent}{require}{delim}\"\n        requireJson = f\"\"\"{{   \n  \"require\": {{\n{requireList} \n  }} \n}}\"\"\"\n        return requireJson\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getContainerName","title":"<code>getContainerName(kind, separator)</code>","text":"<p>get my container Name</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getContainerName(self, kind: str, separator: str):\n    \"\"\"\n    get my container Name\n    \"\"\"\n    containerName = f\"{self.config.container_base_name}{separator}{kind}\"\n    return containerName\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getContainers","title":"<code>getContainers()</code>","text":"<p>get my containers</p> <p>Returns:</p> Type Description <p>Tuple(</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getContainers(self):\n    \"\"\"\n    get my containers\n\n    Returns:\n        Tuple(\n    \"\"\"\n    self.dbContainer = None\n    self.mwContainer = None\n    containerMap = DockerMap.getContainerMap()\n    for separator in [\"-\", \"_\"]:\n        dbContainerName = self.getContainerName(\"db\", separator)\n        mwContainerName = self.getContainerName(\"mw\", separator)\n        if dbContainerName in containerMap:\n            self.dbContainer = DockerContainer(\n                dbContainerName, \"database\", containerMap[dbContainerName]\n            )\n        if mwContainerName in containerMap:\n            self.mwContainer = DockerContainer(\n                mwContainerName, \"webserver\", containerMap[mwContainerName]\n            )\n    return self.mwContainer, self.dbContainer\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getJinjaEnv","title":"<code>getJinjaEnv()</code>","text":"<p>get a Jinja2 environment</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getJinjaEnv(self):\n    \"\"\"\n    get a Jinja2 environment\n    \"\"\"\n    scriptdir = os.path.dirname(os.path.realpath(__file__))\n    resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n    template_dir = os.path.realpath(f\"{resourcePath}/templates\")\n    # print(f\"jinja template directory is {template_dir}\")\n    env = Environment(loader=FileSystemLoader(template_dir))\n    return env\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.initDB","title":"<code>initDB()</code>","text":"<p>initialize my SQL database</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def initDB(self):\n    \"\"\"\n    initialize my SQL database\n    \"\"\"\n    # restore the mySQL dump data\n    self.execute(\"/root/initdb.sh\")\n    # update the database e.g. to initialize Semantic MediaWiki tables\n    self.execute(\"/root/update.sh\")\n    # add an initial sysop user as specified\n    self.execute(\"/root/addSysopUser.sh\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.installExtensions","title":"<code>installExtensions()</code>","text":"<p>install all extensions</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def installExtensions(self):\n    \"\"\"\n    install all extensions\n    \"\"\"\n    self.execute(\"/root/installExtensions.sh\")\n    self.execute(\"/root/fixPermissions.sh\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.optionalWrite","title":"<code>optionalWrite(targetPath, content, overwrite=False)</code>","text":"<p>optionally Write the modified content to the given targetPath</p> <p>Parameters:</p> Name Type Description Default <code>targetPath(str)</code> <p>the path to write the content to</p> required <code>content(str)</code> <p>the content to write</p> required <code>overwrite(bool)</code> <p>if True overwrite the existing content</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def optionalWrite(self, targetPath: str, content: str, overwrite: bool = False):\n    \"\"\"\n    optionally Write the modified content to the given targetPath\n\n    Args:\n        targetPath(str): the path to write the content to\n        content(str): the content to write\n        overwrite(bool): if True overwrite the existing content\n    \"\"\"\n    if not overwrite and os.path.isfile(targetPath):\n        if self.config.verbose:\n            print(f\"{targetPath} already exists!\")\n        return\n    with open(targetPath, \"w\") as targetFile:\n        targetFile.write(content)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.sqlQuery","title":"<code>sqlQuery(query)</code>","text":"<p>run the given SQL query</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def sqlQuery(self, query):\n    \"\"\"\n    run the given SQL query\n    \"\"\"\n    if self.dbConn and self.dbConn.is_connected():\n        cursor = self.dbConn.cursor()\n        cursor.execute(query)\n        rows = cursor.fetchall()\n        cursor.close()\n        return rows\n    else:\n        if self.config.verbose:\n            print(\n                f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} not established\"\n            )\n        return None\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.start","title":"<code>start(forceRebuild=False, withInitDB=True)</code>","text":"<p>start my containers</p> <p>Parameters:</p> Name Type Description Default <code>forceRebuild(bool)</code> <p>if True force rebuilding</p> required <code>withInitDB(bool)</code> <p>if True intialize my database</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def start(self, forceRebuild: bool = False, withInitDB=True):\n    \"\"\"\n    start my containers\n\n    Args:\n        forceRebuild(bool): if True force rebuilding\n        withInitDB(bool): if True intialize my database\n    \"\"\"\n    self.up(forceRebuild=forceRebuild)\n    if withInitDB:\n        if self.config.verbose:\n            print(\"Initializing MediaWiki SQL tables ...\")\n        dbStatus = self.checkDBConnection()\n        if dbStatus.ok:\n            # first install extensions\n            self.installExtensions()\n            # then create and fill database and update it\n            self.initDB()\n            # then run startUp scripts\n            self.startUp()\n    if self.config.verbose:\n        print(\n            f\"MediaWiki {self.config.container_base_name} is ready at {self.config.full_url}\"\n        )\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.startUp","title":"<code>startUp()</code>","text":"<p>run startUp scripts</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def startUp(self):\n    \"\"\"\n    run startUp scripts\n    \"\"\"\n    # fix permissions\n    self.execute(\"/root/fixPermissions.sh\")\n    # add language icons\n    self.execute(\"/root/lang.sh\", \"--site\", \"/var/www/html\")\n    # start cron job\n    self.execute(\"/root/addCronTabEntry.sh\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.up","title":"<code>up(forceRebuild=False)</code>","text":"<p>start this docker application</p> <p>Parameters:</p> Name Type Description Default <code>forceRebuild(bool)</code> <p>if true stop and remove the existing containers</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def up(self, forceRebuild: bool = False):\n    \"\"\"\n    start this docker application\n\n    Args:\n        forceRebuild(bool): if true stop and remove the existing containers\n    \"\"\"\n    DockerApplication.checkDockerEnvironment(self.config.debug)\n    if self.config.verbose:\n        print(\n            f\"starting {self.config.container_base_name} {self.config.version} docker application ...\"\n        )\n    if forceRebuild:\n        for docker_container in [self.dbContainer, self.mwContainer]:\n            if docker_container is not None:\n                container = docker_container.container\n                try:\n                    container_name = container.name\n                    if self.config.verbose:\n                        print(f\"stopping and removing container {container_name}\")\n                except Exception as container_ex:\n                    container = None\n                if container:\n                    try:\n                        container.stop()\n                    except Exception as stop_ex:\n                        if self.config.verbose:\n                            print(f\"stop failed with {str(stop_ex)}\")\n                        pass\n                    try:\n                        container.remove()\n                    except Exception as remove_ex:\n                        if self.config.verbose:\n                            print(f\"removed failed with {str(remove_ex)}\")\n                        pass\n                pass\n\n    # remember current directory\n    cwd = os.getcwd()\n\n    # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n    os.chdir(self.docker_path)\n    # project_config = docker.compose.config()\n    if forceRebuild:\n        docker.compose.build()\n    # run docker compose up\n    # this might take a while e.g. downloading\n    # run docker compose up\n    try:\n        docker.compose.up(detach=True, force_recreate=forceRebuild)\n    except Exception as de:\n        print(f\"docker compose up failed in {self.docker_path}\")\n        raise de\n        pass\n    # switch back to previous current directory\n    os.chdir(cwd)\n\n    return self.getContainers()\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer","title":"<code>DockerContainer</code>","text":"<p>helper class for docker container info</p> Source code in <code>mwdocker/docker.py</code> <pre><code>class DockerContainer:\n    \"\"\"\n    helper class for docker container info\n    \"\"\"\n\n    def __init__(self, name, kind, container):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.name = name\n        self.kind = kind\n        self.container = container\n\n    def check(self):\n        \"\"\"\n        check the given docker container\n\n        print check message and Return if container is running\n\n        Args:\n            dc: the docker container\n\n        Returns:\n            bool: True if the container is not None\n        \"\"\"\n        ok = self.container.state.running\n        msg = f\"mediawiki {self.kind} container {self.name}\"\n        return Logger.check_and_log(msg, ok)\n\n    def getHostPort(self, local_port: int = 80) -&gt; int:\n        \"\"\"\n        get the host port for the given local port\n\n        Args:\n            local_port(int): the local port to get the mapping for\n\n        Returns:\n            int: the  host port or None\n        \"\"\"\n        host_port = None\n        pb_dict = self.container.host_config.port_bindings\n        p_local = f\"{local_port}/tcp\"\n        if p_local in pb_dict:\n            pb = pb_dict[p_local][0]\n            host_port = pb.host_port\n        return host_port\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.__init__","title":"<code>__init__(name, kind, container)</code>","text":"<p>constructor</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def __init__(self, name, kind, container):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.name = name\n    self.kind = kind\n    self.container = container\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.check","title":"<code>check()</code>","text":"<p>check the given docker container</p> <p>print check message and Return if container is running</p> <p>Parameters:</p> Name Type Description Default <code>dc</code> <p>the docker container</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the container is not None</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def check(self):\n    \"\"\"\n    check the given docker container\n\n    print check message and Return if container is running\n\n    Args:\n        dc: the docker container\n\n    Returns:\n        bool: True if the container is not None\n    \"\"\"\n    ok = self.container.state.running\n    msg = f\"mediawiki {self.kind} container {self.name}\"\n    return Logger.check_and_log(msg, ok)\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.getHostPort","title":"<code>getHostPort(local_port=80)</code>","text":"<p>get the host port for the given local port</p> <p>Parameters:</p> Name Type Description Default <code>local_port(int)</code> <p>the local port to get the mapping for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the  host port or None</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getHostPort(self, local_port: int = 80) -&gt; int:\n    \"\"\"\n    get the host port for the given local port\n\n    Args:\n        local_port(int): the local port to get the mapping for\n\n    Returns:\n        int: the  host port or None\n    \"\"\"\n    host_port = None\n    pb_dict = self.container.host_config.port_bindings\n    p_local = f\"{local_port}/tcp\"\n    if p_local in pb_dict:\n        pb = pb_dict[p_local][0]\n        host_port = pb.host_port\n    return host_port\n</code></pre>"},{"location":"#mwdocker.docker.DockerMap","title":"<code>DockerMap</code>","text":"<p>helper class to convert lists of docker elements to maps for improved lookup functionality</p> Source code in <code>mwdocker/docker.py</code> <pre><code>class DockerMap:\n    \"\"\"\n    helper class to convert lists of docker elements to maps for improved\n    lookup functionality\n    \"\"\"\n\n    @staticmethod\n    def getContainerMap():\n        \"\"\"\n        get a map/dict of containers by container name\n        \"\"\"\n        containerMap = {}\n        for container in docker.container.list():\n            containerMap[container.name] = container\n            pass\n        return containerMap\n</code></pre>"},{"location":"#mwdocker.docker.DockerMap.getContainerMap","title":"<code>getContainerMap()</code>  <code>staticmethod</code>","text":"<p>get a map/dict of containers by container name</p> Source code in <code>mwdocker/docker.py</code> <pre><code>@staticmethod\ndef getContainerMap():\n    \"\"\"\n    get a map/dict of containers by container name\n    \"\"\"\n    containerMap = {}\n    for container in docker.container.list():\n        containerMap[container.name] = container\n        pass\n    return containerMap\n</code></pre>"},{"location":"#mwdocker.html_table","title":"<code>html_table</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#mwdocker.html_table.HtmlTables","title":"<code>HtmlTables</code>","text":"<p>               Bases: <code>WebScrape</code></p> <p>HtmlTables extractor</p> Source code in <code>mwdocker/html_table.py</code> <pre><code>class HtmlTables(WebScrape):\n    \"\"\"\n    HtmlTables extractor\n    \"\"\"\n\n    def __init__(self, url: str, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n\n        url(str): the url to read the tables from\n        debug(bool): if True switch on debugging\n        showHtml(bool): if True show the HTML retrieved\n        \"\"\"\n        super().__init__(debug, showHtml)\n        self.soup = super().getSoup(url, showHtml)\n\n    def get_tables(self, header_tag: str = None) -&gt; dict:\n        \"\"\"\n        get all tables from my soup as a list of list of dicts\n\n        Args:\n            header_tag(str): if set search the table name from the given header tag\n\n        Return:\n            dict: the list of list of dicts for all tables\n\n        \"\"\"\n        tables = {}\n        for i, table in enumerate(self.soup.find_all(\"table\")):\n            fields = []\n            table_data = []\n            category = None\n            for tr in table.find_all(\"tr\", recursive=True):\n                for th in tr.find_all(\"th\", recursive=True):\n                    if \"colspan\" in th.attrs:\n                        category = th.text\n                    else:\n                        fields.append(th.text)\n            for tr in table.find_all(\"tr\", recursive=True):\n                record = {}\n                for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                    record[fields[i]] = td.text\n                if record:\n                    if category:\n                        record[\"category\"] = category\n                    table_data.append(record)\n            if header_tag is not None:\n                header = table.find_previous_sibling(header_tag)\n                table_name = header.text\n            else:\n                table_name = f\"table{i}\"\n            tables[table_name] = table_data\n        return tables\n</code></pre>"},{"location":"#mwdocker.html_table.HtmlTables.__init__","title":"<code>__init__(url, debug=False, showHtml=False)</code>","text":"<p>Constructor</p> <p>url(str): the url to read the tables from debug(bool): if True switch on debugging showHtml(bool): if True show the HTML retrieved</p> Source code in <code>mwdocker/html_table.py</code> <pre><code>def __init__(self, url: str, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n\n    url(str): the url to read the tables from\n    debug(bool): if True switch on debugging\n    showHtml(bool): if True show the HTML retrieved\n    \"\"\"\n    super().__init__(debug, showHtml)\n    self.soup = super().getSoup(url, showHtml)\n</code></pre>"},{"location":"#mwdocker.html_table.HtmlTables.get_tables","title":"<code>get_tables(header_tag=None)</code>","text":"<p>get all tables from my soup as a list of list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>header_tag(str)</code> <p>if set search the table name from the given header tag</p> required Return <p>dict: the list of list of dicts for all tables</p> Source code in <code>mwdocker/html_table.py</code> <pre><code>def get_tables(self, header_tag: str = None) -&gt; dict:\n    \"\"\"\n    get all tables from my soup as a list of list of dicts\n\n    Args:\n        header_tag(str): if set search the table name from the given header tag\n\n    Return:\n        dict: the list of list of dicts for all tables\n\n    \"\"\"\n    tables = {}\n    for i, table in enumerate(self.soup.find_all(\"table\")):\n        fields = []\n        table_data = []\n        category = None\n        for tr in table.find_all(\"tr\", recursive=True):\n            for th in tr.find_all(\"th\", recursive=True):\n                if \"colspan\" in th.attrs:\n                    category = th.text\n                else:\n                    fields.append(th.text)\n        for tr in table.find_all(\"tr\", recursive=True):\n            record = {}\n            for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                record[fields[i]] = td.text\n            if record:\n                if category:\n                    record[\"category\"] = category\n                table_data.append(record)\n        if header_tag is not None:\n            header = table.find_previous_sibling(header_tag)\n            table_name = header.text\n        else:\n            table_name = f\"table{i}\"\n        tables[table_name] = table_data\n    return tables\n</code></pre>"},{"location":"#mwdocker.logger","title":"<code>logger</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#mwdocker.logger.Logger","title":"<code>Logger</code>","text":"<p>               Bases: <code>object</code></p> <p>simple logger</p> Source code in <code>mwdocker/logger.py</code> <pre><code>class Logger(object):\n    \"\"\"\n    simple logger\n    \"\"\"\n\n    @classmethod\n    def check_and_log(cls, msg: str, ok: bool) -&gt; bool:\n        \"\"\"\n        log the given message with the given ok flag\n\n        Args:\n            msg(str): the message to log/print\n            ok(bool): if True show \u2705 marker else \u274c\n\n        Return:\n            bool: the ok parameter for fluid syntax\n        \"\"\"\n        marker = \"\u2705\" if ok else \"\u274c\"\n        print(f\"{msg}:{marker}\")\n        return ok\n\n    @classmethod\n    def check_and_log_equal(self, nameA, valueA, nameB, valueB):\n        msg = f\"{nameA} {valueA}= {nameB} {valueB}?\"\n        return self.check_and_log(msg, valueA == valueB)\n</code></pre>"},{"location":"#mwdocker.logger.Logger.check_and_log","title":"<code>check_and_log(msg, ok)</code>  <code>classmethod</code>","text":"<p>log the given message with the given ok flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to log/print</p> required <code>ok(bool)</code> <p>if True show \u2705 marker else \u274c</p> required Return <p>bool: the ok parameter for fluid syntax</p> Source code in <code>mwdocker/logger.py</code> <pre><code>@classmethod\ndef check_and_log(cls, msg: str, ok: bool) -&gt; bool:\n    \"\"\"\n    log the given message with the given ok flag\n\n    Args:\n        msg(str): the message to log/print\n        ok(bool): if True show \u2705 marker else \u274c\n\n    Return:\n        bool: the ok parameter for fluid syntax\n    \"\"\"\n    marker = \"\u2705\" if ok else \"\u274c\"\n    print(f\"{msg}:{marker}\")\n    return ok\n</code></pre>"},{"location":"#mwdocker.mariadb","title":"<code>mariadb</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#mwdocker.mariadb.MariaDB","title":"<code>MariaDB</code>","text":"<p>Maria DB handling</p> Source code in <code>mwdocker/mariadb.py</code> <pre><code>class MariaDB:\n    \"\"\"\n    Maria DB handling\n    \"\"\"\n\n    @classmethod\n    def getVersion(cls, versionStr: str) -&gt; str:\n        \"\"\"\n        get the version from the version String\n\n        Args:\n            versionStr(str): the version string to check\n\n        Return:\n            str: the extracted version\n        \"\"\"\n        # version is anything which is not a dot at beginning\n        # two times may be ending with dash\n        version_match = re.search(r\"([^.]+[.]+[^.-]+)\", versionStr)\n        version = \"?\"\n        if version_match:\n            version = version_match.group(1)\n        return version\n</code></pre>"},{"location":"#mwdocker.mariadb.MariaDB.getVersion","title":"<code>getVersion(versionStr)</code>  <code>classmethod</code>","text":"<p>get the version from the version String</p> <p>Parameters:</p> Name Type Description Default <code>versionStr(str)</code> <p>the version string to check</p> required Return <p>str: the extracted version</p> Source code in <code>mwdocker/mariadb.py</code> <pre><code>@classmethod\ndef getVersion(cls, versionStr: str) -&gt; str:\n    \"\"\"\n    get the version from the version String\n\n    Args:\n        versionStr(str): the version string to check\n\n    Return:\n        str: the extracted version\n    \"\"\"\n    # version is anything which is not a dot at beginning\n    # two times may be ending with dash\n    version_match = re.search(r\"([^.]+[.]+[^.-]+)\", versionStr)\n    version = \"?\"\n    if version_match:\n        version = version_match.group(1)\n    return version\n</code></pre>"},{"location":"#mwdocker.mw","title":"<code>mw</code>","text":"<p>Created on 2021-06-23</p> <p>@author: wf</p>"},{"location":"#mwdocker.mw.Extension","title":"<code>Extension</code>","text":"<p>represents a MediaWiki extension</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@lod_storable\nclass Extension:\n    \"\"\"\n    represents a MediaWiki extension\n    \"\"\"\n\n    name: str\n    url: str\n    extension: Optional[str] = None\n    purpose: Optional[str] = None\n    giturl: Optional[str] = None\n    composer: Optional[str] = None\n    wikidata_id: Optional[str] = None\n    since: Optional[str] = None\n    localSettings: Optional[str] = None\n    require_once_until: Optional[str] = None\n\n    @classmethod\n    def getSamples(cls):\n        samplesLOD = [\n            {\n                \"name\": \"Admin Links\",\n                \"extension\": \"AdminLinks\",\n                \"url\": \"https://www.mediawiki.org/wiki/Extension:Admin_Links\",\n                \"purpose\": \"\"\"Admin Links is an extension to MediaWiki that defines a special page, \"Special:AdminLinks\",\nthat holds links meant to be helpful for wiki administrators;\nit is meant to serve as a \"control panel\" for the functions an administrator would typically perform in a wiki.\nAll users can view this page; however, for those with the 'adminlinks' permission (sysops/administrators, by default),\na link to the page also shows up in their \"Personal URLs\", between \"Talk\" and \"Preferences\".\"\"\",\n                \"since\": datetime.fromisoformat(\"2009-05-13\"),\n                \"giturl\": \"https://gerrit.wikimedia.org/r/mediawiki/extensions/AdminLinks.git\",\n                \"localSettings\": \"\",\n            }\n        ]\n        return samplesLOD\n\n    @classmethod\n    def fromSpecialVersionTR(cls, exttr, debug=False):\n        \"\"\"\n        Construct an extension from a beautifl soup TR tag\n        derived from Special:Version\n\n        Args:\n            exttr: the beautiful soup TR tag\n            debug(bool): if True show debugging information\n        \"\"\"\n        ext = None\n        purpose = None\n        extNameTag = exttr.find(attrs={\"class\": \"mw-version-ext-name\"})\n        extPurposeTag = exttr.find(attrs={\"class\": \"mw-version-ext-description\"})\n        if extNameTag:\n            name = extNameTag.string\n            extension = name.replace(\" \", \"\")\n            url = extNameTag.get(\"href\")\n            if extPurposeTag and extPurposeTag.string:\n                purpose = extPurposeTag.string\n            ext = Extension(name=name, extension=extension, url=url, purpose=purpose)\n            ext.getDetailsFromUrl(debug=debug)\n        return ext\n\n    def __str__(self):\n        text = \"\"\n        delim = \"\"\n        samples = self.getJsonTypeSamples()\n        for attr in LOD.getFields(samples):\n            if hasattr(self, attr) and self.attr:\n                text += f\"{delim}{attr}={self.attr}\"\n                delim = \"\\n\"\n        return text\n\n    def getDetailsFromUrl(self, showHtml=False, debug=False):\n        \"\"\"\n        get more details from my url\n        \"\"\"\n        webscrape = WebScrape()\n        try:\n            soup = webscrape.getSoup(self.url, showHtml=showHtml)\n            for link in soup.findAll(\"a\", attrs={\"class\": \"external text\"}):\n                if (\"GitHub\" == link.string) or (\"git repository URL\") == link.string:\n                    self.giturl = link.get(\"href\")\n        except urllib.error.HTTPError as herr:\n            if debug:\n                print(f\"HTTPError {str(herr)} for {self.url}\")\n\n    def asWikiMarkup(self):\n        \"\"\"\n        return me as wiki Markup\n        \"\"\"\n        samples = self.getJsonTypeSamples()\n        nameValues = \"\"\n        for attr in LOD.getFields(samples):\n            if hasattr(self, attr) and self.attr:\n                nameValues += f\"|{attr}={self.attr}\\n\"\n        wikison = f\"\"\"{{{{Extension\n{nameValues}\n}}}}\"\"\"\n        return wikison\n\n    def getLocalSettingsLine(self, mwShortVersion: str):\n        \"\"\"\n        get my local settings line\n\n        Args:\n            mwShortVersion(str): the MediaWiki short version e.g. 127\n\n        Returns:\n            entry for LocalSettings\n        \"\"\"\n        localSettingsLine=\"\"\n        if self.extension:\n            localSettingsLine = f\"wfLoadExtension( '{self.extension}' );\"\n        if self.require_once_until:\n            if self.require_once_until &gt;= mwShortVersion:\n                localSettingsLine = f'require_once \"$IP/extensions/{self.extension}/{self.extension}.php\";'\n\n        if self.localSettings:\n            localSettingsLine += f\"\\n  {self.localSettings}\"\n        return localSettingsLine\n\n    def asScript(self, branch=\"master\"):\n        \"\"\"\n        return me as a shell Script command line list\n\n        Args:\n            branch(str): the branch to clone\n        \"\"\"\n        if self.giturl:\n            if \"//github.com/wikimedia/\" in self.giturl:\n                # glone from the branch\n                return f\"git clone {self.giturl} --single-branch --branch {branch} {self.extension}\"\n            else:\n                return f\"git clone {self.giturl} {self.extension}\"\n        else:\n            text = \"# no installation script command specified\"\n            if self.composer:\n                text += f\"\\n# installed with composer require {self.composer}\"\n            return text\n</code></pre>"},{"location":"#mwdocker.mw.Extension.asScript","title":"<code>asScript(branch='master')</code>","text":"<p>return me as a shell Script command line list</p> <p>Parameters:</p> Name Type Description Default <code>branch(str)</code> <p>the branch to clone</p> required Source code in <code>mwdocker/mw.py</code> <pre><code>def asScript(self, branch=\"master\"):\n    \"\"\"\n    return me as a shell Script command line list\n\n    Args:\n        branch(str): the branch to clone\n    \"\"\"\n    if self.giturl:\n        if \"//github.com/wikimedia/\" in self.giturl:\n            # glone from the branch\n            return f\"git clone {self.giturl} --single-branch --branch {branch} {self.extension}\"\n        else:\n            return f\"git clone {self.giturl} {self.extension}\"\n    else:\n        text = \"# no installation script command specified\"\n        if self.composer:\n            text += f\"\\n# installed with composer require {self.composer}\"\n        return text\n</code></pre>"},{"location":"#mwdocker.mw.Extension.asWikiMarkup","title":"<code>asWikiMarkup()</code>","text":"<p>return me as wiki Markup</p> Source code in <code>mwdocker/mw.py</code> <pre><code>    def asWikiMarkup(self):\n        \"\"\"\n        return me as wiki Markup\n        \"\"\"\n        samples = self.getJsonTypeSamples()\n        nameValues = \"\"\n        for attr in LOD.getFields(samples):\n            if hasattr(self, attr) and self.attr:\n                nameValues += f\"|{attr}={self.attr}\\n\"\n        wikison = f\"\"\"{{{{Extension\n{nameValues}\n}}}}\"\"\"\n        return wikison\n</code></pre>"},{"location":"#mwdocker.mw.Extension.fromSpecialVersionTR","title":"<code>fromSpecialVersionTR(exttr, debug=False)</code>  <code>classmethod</code>","text":"<p>Construct an extension from a beautifl soup TR tag derived from Special:Version</p> <p>Parameters:</p> Name Type Description Default <code>exttr</code> <p>the beautiful soup TR tag</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required Source code in <code>mwdocker/mw.py</code> <pre><code>@classmethod\ndef fromSpecialVersionTR(cls, exttr, debug=False):\n    \"\"\"\n    Construct an extension from a beautifl soup TR tag\n    derived from Special:Version\n\n    Args:\n        exttr: the beautiful soup TR tag\n        debug(bool): if True show debugging information\n    \"\"\"\n    ext = None\n    purpose = None\n    extNameTag = exttr.find(attrs={\"class\": \"mw-version-ext-name\"})\n    extPurposeTag = exttr.find(attrs={\"class\": \"mw-version-ext-description\"})\n    if extNameTag:\n        name = extNameTag.string\n        extension = name.replace(\" \", \"\")\n        url = extNameTag.get(\"href\")\n        if extPurposeTag and extPurposeTag.string:\n            purpose = extPurposeTag.string\n        ext = Extension(name=name, extension=extension, url=url, purpose=purpose)\n        ext.getDetailsFromUrl(debug=debug)\n    return ext\n</code></pre>"},{"location":"#mwdocker.mw.Extension.getDetailsFromUrl","title":"<code>getDetailsFromUrl(showHtml=False, debug=False)</code>","text":"<p>get more details from my url</p> Source code in <code>mwdocker/mw.py</code> <pre><code>def getDetailsFromUrl(self, showHtml=False, debug=False):\n    \"\"\"\n    get more details from my url\n    \"\"\"\n    webscrape = WebScrape()\n    try:\n        soup = webscrape.getSoup(self.url, showHtml=showHtml)\n        for link in soup.findAll(\"a\", attrs={\"class\": \"external text\"}):\n            if (\"GitHub\" == link.string) or (\"git repository URL\") == link.string:\n                self.giturl = link.get(\"href\")\n    except urllib.error.HTTPError as herr:\n        if debug:\n            print(f\"HTTPError {str(herr)} for {self.url}\")\n</code></pre>"},{"location":"#mwdocker.mw.Extension.getLocalSettingsLine","title":"<code>getLocalSettingsLine(mwShortVersion)</code>","text":"<p>get my local settings line</p> <p>Parameters:</p> Name Type Description Default <code>mwShortVersion(str)</code> <p>the MediaWiki short version e.g. 127</p> required <p>Returns:</p> Type Description <p>entry for LocalSettings</p> Source code in <code>mwdocker/mw.py</code> <pre><code>def getLocalSettingsLine(self, mwShortVersion: str):\n    \"\"\"\n    get my local settings line\n\n    Args:\n        mwShortVersion(str): the MediaWiki short version e.g. 127\n\n    Returns:\n        entry for LocalSettings\n    \"\"\"\n    localSettingsLine=\"\"\n    if self.extension:\n        localSettingsLine = f\"wfLoadExtension( '{self.extension}' );\"\n    if self.require_once_until:\n        if self.require_once_until &gt;= mwShortVersion:\n            localSettingsLine = f'require_once \"$IP/extensions/{self.extension}/{self.extension}.php\";'\n\n    if self.localSettings:\n        localSettingsLine += f\"\\n  {self.localSettings}\"\n    return localSettingsLine\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList","title":"<code>ExtensionList</code>","text":"<p>represents a list of MediaWiki extensions</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@lod_storable\nclass ExtensionList:\n    \"\"\"\n    represents a list of MediaWiki extensions\n    \"\"\"\n\n    extensions: List[Extension] = field(default_factory=list)\n\n    @staticmethod\n    def storeFilePrefix():\n        \"\"\"\n        get my storeFilePrefix\n\n        Returns:\n            str: the path to where my stored files (e.g. JSON) should be kept\n        \"\"\"\n        scriptdir = os.path.dirname(os.path.realpath(__file__))\n        resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n        storeFilePrefix = f\"{resourcePath}/extensions\"\n        return storeFilePrefix\n\n    @classmethod\n    def fromSpecialVersion(\n        cls, url: str, excludes=[\"skin\", \"editor\"], showHtml=False, debug=False\n    ):\n        \"\"\"\n        get an extension List from the given url\n\n        Args:\n            url(str): the Special:Version MediaWiki page to read the information from\n            exclude (list): a list of types of extensions to exclude\n            showHtml(bool): True if the html code should be printed for debugging\n            debug(bool): True if debugging should be active\n\n        Returns:\n            ExtensionList: an extension list derived from the url\n        \"\"\"\n        webscrape = WebScrape()\n        soup = webscrape.getSoup(url, showHtml=showHtml)\n\n        # search for\n        # &lt;tr class=\"mw-version-ext\" id=\"mw-version-ext-media-PDF_Handler\"&gt;\n        exttrs = soup.findAll(attrs={\"class\": \"mw-version-ext\"})\n        extList = ExtensionList()\n        for exttr in exttrs:\n            if showHtml:\n                print(exttr)\n            doExclude = False\n            for exclude in excludes:\n                if f\"-{exclude}-\" in exttr.get(\"id\"):\n                    doExclude = True\n            if not doExclude:\n                ext = Extension.fromSpecialVersionTR(exttr, debug=debug)\n                if ext:\n                    extList.extensions.append(ext)\n        return extList\n\n    @classmethod\n    def restore(cls) -&gt; \"ExtensionList\":\n        \"\"\"\n        restore the extension list\n        \"\"\"\n        path = ExtensionList.storeFilePrefix()\n        yaml_file = f\"{path}.yaml\"\n        extlist = ExtensionList.load_from_yaml_file(yaml_file)\n        return extlist\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList.fromSpecialVersion","title":"<code>fromSpecialVersion(url, excludes=['skin', 'editor'], showHtml=False, debug=False)</code>  <code>classmethod</code>","text":"<p>get an extension List from the given url</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the Special:Version MediaWiki page to read the information from</p> required <code>exclude</code> <code>list</code> <p>a list of types of extensions to exclude</p> required <code>showHtml(bool)</code> <p>True if the html code should be printed for debugging</p> required <code>debug(bool)</code> <p>True if debugging should be active</p> required <p>Returns:</p> Name Type Description <code>ExtensionList</code> <p>an extension list derived from the url</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@classmethod\ndef fromSpecialVersion(\n    cls, url: str, excludes=[\"skin\", \"editor\"], showHtml=False, debug=False\n):\n    \"\"\"\n    get an extension List from the given url\n\n    Args:\n        url(str): the Special:Version MediaWiki page to read the information from\n        exclude (list): a list of types of extensions to exclude\n        showHtml(bool): True if the html code should be printed for debugging\n        debug(bool): True if debugging should be active\n\n    Returns:\n        ExtensionList: an extension list derived from the url\n    \"\"\"\n    webscrape = WebScrape()\n    soup = webscrape.getSoup(url, showHtml=showHtml)\n\n    # search for\n    # &lt;tr class=\"mw-version-ext\" id=\"mw-version-ext-media-PDF_Handler\"&gt;\n    exttrs = soup.findAll(attrs={\"class\": \"mw-version-ext\"})\n    extList = ExtensionList()\n    for exttr in exttrs:\n        if showHtml:\n            print(exttr)\n        doExclude = False\n        for exclude in excludes:\n            if f\"-{exclude}-\" in exttr.get(\"id\"):\n                doExclude = True\n        if not doExclude:\n            ext = Extension.fromSpecialVersionTR(exttr, debug=debug)\n            if ext:\n                extList.extensions.append(ext)\n    return extList\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList.restore","title":"<code>restore()</code>  <code>classmethod</code>","text":"<p>restore the extension list</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@classmethod\ndef restore(cls) -&gt; \"ExtensionList\":\n    \"\"\"\n    restore the extension list\n    \"\"\"\n    path = ExtensionList.storeFilePrefix()\n    yaml_file = f\"{path}.yaml\"\n    extlist = ExtensionList.load_from_yaml_file(yaml_file)\n    return extlist\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList.storeFilePrefix","title":"<code>storeFilePrefix()</code>  <code>staticmethod</code>","text":"<p>get my storeFilePrefix</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the path to where my stored files (e.g. JSON) should be kept</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@staticmethod\ndef storeFilePrefix():\n    \"\"\"\n    get my storeFilePrefix\n\n    Returns:\n        str: the path to where my stored files (e.g. JSON) should be kept\n    \"\"\"\n    scriptdir = os.path.dirname(os.path.realpath(__file__))\n    resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n    storeFilePrefix = f\"{resourcePath}/extensions\"\n    return storeFilePrefix\n</code></pre>"},{"location":"#mwdocker.mwcluster","title":"<code>mwcluster</code>","text":"<p>Created on 2021-08-06 @author: wf</p>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster","title":"<code>MediaWikiCluster</code>","text":"<p>               Bases: <code>object</code></p> <p>a cluster of mediawiki docker Applications</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>class MediaWikiCluster(object):\n    \"\"\"\n    a cluster of mediawiki docker Applications\n    \"\"\"\n\n    # https://hub.docker.com/_/mediawiki\n    # 2023-01-13\n    # MediaWiki Extensions and Skins Security Release Supplement (1.35.9/1.38.4/1.39.1)\n    # 2023-02-23 1.39.2 released\n    # 2023-04-04 1.39.3 upgrade\n    # 2023-10-04 1.39.5 upgrade\n    # 2024-04-15 1.39.7 upgrade\n\n    def __init__(self, config: MwClusterConfig):\n        \"\"\"\n        Constructor\n\n        Args:\n            config(MWClusterConfig): the MediaWiki Cluster Configuration to use\n        \"\"\"\n        self.config = config\n        self.apps = {}\n\n    def createApps(self, withGenerate: bool = True) -&gt; dict:\n        \"\"\"\n        create my apps\n\n        Args:\n            withGenerate(bool): if True generate the config files\n\n        Returns:\n            dict(str): a dict of apps by version\n        \"\"\"\n        app_count = len(self.config.versions)\n        for i, version in enumerate(self.config.versions):\n            mwApp = self.getDockerApplication(i, app_count, version)\n            if withGenerate:\n                mwApp.generateAll(overwrite=self.config.forceRebuild)\n            self.apps[version] = mwApp\n        return self.apps\n\n    def checkDocker(self) -&gt; int:\n        \"\"\"\n        check the Docker environment\n\n        print an error message on stderr if check fails\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n\n        \"\"\"\n        errMsg = DockerApplication.checkDockerEnvironment(self.config.debug)\n        if errMsg is not None:\n            print(errMsg, file=sys.stderr)\n            return 1\n        return 0\n\n    def start(self, forceRebuild: bool = False, withInitDB=True) -&gt; int:\n        \"\"\"\n        create and start the composer applications\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n\n        for version in self.config.versions:\n            mwApp = self.apps[version]\n            mwApp.start(forceRebuild=forceRebuild, withInitDB=withInitDB)\n        return 0\n\n    def down(self, forceRebuild: bool = False):\n        \"\"\"\n        run docker compose down\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n        for _i, version in enumerate(self.config.versions):\n            mwApp = self.apps[version]\n            mwApp.down(forceRebuild)\n\n    def listWikis(self) -&gt; int:\n        \"\"\"\n        list my wikis\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n        for i, version in enumerate(self.config.versions):\n            mwApp = self.apps[version]\n            mw, db = mwApp.getContainers()\n            config = mwApp.config\n            ok = mw and db\n            msg = f\"{i+1}:{config.container_base_name} {config.fullVersion}\"\n            Logger.check_and_log(msg, ok)\n        return exitCode\n\n    def check(self) -&gt; int:\n        \"\"\"\n        check the composer applications\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n\n        for i, version in enumerate(self.config.versions):\n            mwApp = self.apps[version]\n            msg = f\"{i+1}:checking {version} ...\"\n            print(msg)\n            exitCode = mwApp.check()\n        return exitCode\n\n    def close(self):\n        \"\"\"\n        close my apps\n        \"\"\"\n        for mwApp in self.apps.values():\n            mwApp.close()\n\n    def getDockerApplication(self, i: int, count: int, version: str):\n        \"\"\"\n        get the docker application for the given version index and version\n\n        Args:\n            i(int): the index of the version\n            count(int): total number of Docker applications in this cluster\n            version(str): the mediawiki version to use\n\n        Returns:\n            DockerApplication: the docker application\n        \"\"\"\n        # please note that we are using the subclass MwClusterConfig here although\n        # we only need the superclass MwConfig - we let inheritance work here for us but\n        # have to ignore the superfluous fields\n        appConfig = dataclasses.replace(self.config)\n        appConfig.extensionMap = self.config.extensionMap.copy()\n        appConfig.version = version\n        appConfig.port = self.config.base_port + i\n        appConfig.sql_port = self.config.sql_port + i\n        # let post_init create a new container_base_name\n        if count &gt; 1:\n            appConfig.container_base_name = None\n        appConfig.__post_init__()\n        mwApp = DockerApplication(config=appConfig)\n        return mwApp\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.__init__","title":"<code>__init__(config)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>config(MWClusterConfig)</code> <p>the MediaWiki Cluster Configuration to use</p> required Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def __init__(self, config: MwClusterConfig):\n    \"\"\"\n    Constructor\n\n    Args:\n        config(MWClusterConfig): the MediaWiki Cluster Configuration to use\n    \"\"\"\n    self.config = config\n    self.apps = {}\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.check","title":"<code>check()</code>","text":"<p>check the composer applications</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def check(self) -&gt; int:\n    \"\"\"\n    check the composer applications\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n\n    for i, version in enumerate(self.config.versions):\n        mwApp = self.apps[version]\n        msg = f\"{i+1}:checking {version} ...\"\n        print(msg)\n        exitCode = mwApp.check()\n    return exitCode\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.checkDocker","title":"<code>checkDocker()</code>","text":"<p>check the Docker environment</p> <p>print an error message on stderr if check fails</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def checkDocker(self) -&gt; int:\n    \"\"\"\n    check the Docker environment\n\n    print an error message on stderr if check fails\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n\n    \"\"\"\n    errMsg = DockerApplication.checkDockerEnvironment(self.config.debug)\n    if errMsg is not None:\n        print(errMsg, file=sys.stderr)\n        return 1\n    return 0\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.close","title":"<code>close()</code>","text":"<p>close my apps</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def close(self):\n    \"\"\"\n    close my apps\n    \"\"\"\n    for mwApp in self.apps.values():\n        mwApp.close()\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.createApps","title":"<code>createApps(withGenerate=True)</code>","text":"<p>create my apps</p> <p>Parameters:</p> Name Type Description Default <code>withGenerate(bool)</code> <p>if True generate the config files</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>str</code> <p>a dict of apps by version</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def createApps(self, withGenerate: bool = True) -&gt; dict:\n    \"\"\"\n    create my apps\n\n    Args:\n        withGenerate(bool): if True generate the config files\n\n    Returns:\n        dict(str): a dict of apps by version\n    \"\"\"\n    app_count = len(self.config.versions)\n    for i, version in enumerate(self.config.versions):\n        mwApp = self.getDockerApplication(i, app_count, version)\n        if withGenerate:\n            mwApp.generateAll(overwrite=self.config.forceRebuild)\n        self.apps[version] = mwApp\n    return self.apps\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.down","title":"<code>down(forceRebuild=False)</code>","text":"<p>run docker compose down</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def down(self, forceRebuild: bool = False):\n    \"\"\"\n    run docker compose down\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n    for _i, version in enumerate(self.config.versions):\n        mwApp = self.apps[version]\n        mwApp.down(forceRebuild)\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.getDockerApplication","title":"<code>getDockerApplication(i, count, version)</code>","text":"<p>get the docker application for the given version index and version</p> <p>Parameters:</p> Name Type Description Default <code>i(int)</code> <p>the index of the version</p> required <code>count(int)</code> <p>total number of Docker applications in this cluster</p> required <code>version(str)</code> <p>the mediawiki version to use</p> required <p>Returns:</p> Name Type Description <code>DockerApplication</code> <p>the docker application</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def getDockerApplication(self, i: int, count: int, version: str):\n    \"\"\"\n    get the docker application for the given version index and version\n\n    Args:\n        i(int): the index of the version\n        count(int): total number of Docker applications in this cluster\n        version(str): the mediawiki version to use\n\n    Returns:\n        DockerApplication: the docker application\n    \"\"\"\n    # please note that we are using the subclass MwClusterConfig here although\n    # we only need the superclass MwConfig - we let inheritance work here for us but\n    # have to ignore the superfluous fields\n    appConfig = dataclasses.replace(self.config)\n    appConfig.extensionMap = self.config.extensionMap.copy()\n    appConfig.version = version\n    appConfig.port = self.config.base_port + i\n    appConfig.sql_port = self.config.sql_port + i\n    # let post_init create a new container_base_name\n    if count &gt; 1:\n        appConfig.container_base_name = None\n    appConfig.__post_init__()\n    mwApp = DockerApplication(config=appConfig)\n    return mwApp\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.listWikis","title":"<code>listWikis()</code>","text":"<p>list my wikis</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def listWikis(self) -&gt; int:\n    \"\"\"\n    list my wikis\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n    for i, version in enumerate(self.config.versions):\n        mwApp = self.apps[version]\n        mw, db = mwApp.getContainers()\n        config = mwApp.config\n        ok = mw and db\n        msg = f\"{i+1}:{config.container_base_name} {config.fullVersion}\"\n        Logger.check_and_log(msg, ok)\n    return exitCode\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.start","title":"<code>start(forceRebuild=False, withInitDB=True)</code>","text":"<p>create and start the composer applications</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def start(self, forceRebuild: bool = False, withInitDB=True) -&gt; int:\n    \"\"\"\n    create and start the composer applications\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n\n    for version in self.config.versions:\n        mwApp = self.apps[version]\n        mwApp.start(forceRebuild=forceRebuild, withInitDB=withInitDB)\n    return 0\n</code></pre>"},{"location":"#mwdocker.mwcluster.main","title":"<code>main(argv=None)</code>","text":"<p>main program.</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def main(argv=None):  # IGNORE:C0111\n    \"\"\"main program.\"\"\"\n\n    if argv is None:\n        argv = sys.argv[1:]\n\n    program_name = \"mwcluster\"\n    program_version = f\"v{Version.version}\"\n    program_build_date = str(Version.updated)\n    program_version_message = f\"{program_name} ({program_version},{program_build_date})\"\n    program_license = Version.license\n\n    try:\n        # Setup argument parser\n        parser = ArgumentParser(\n            description=program_license, formatter_class=ArgumentDefaultsHelpFormatter\n        )\n        mwClusterConfig = MwClusterConfig()\n        mwClusterConfig.addArgs(parser)\n        parser.add_argument(\n            \"--about\",\n            help=\"show about info [default: %(default)s]\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"--create\", action=\"store_true\", help=\"create wikis [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"--down\", action=\"store_true\", help=\"shutdown wikis [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"--check\",\n            action=\"store_true\",\n            help=\"check the wikis [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--list\", action=\"store_true\", help=\"list the wikis [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=program_version_message\n        )\n        args = parser.parse_args(argv)\n        if args.about:\n            print(program_version_message)\n            print(f\"see {Version.doc_url}\")\n            webbrowser.open(Version.doc_url)\n        else:\n            action = None\n            withGenerate = False\n            if args.check:\n                action = \"checking docker access\"\n            elif args.create:\n                action = \"creating docker compose applications\"\n                withGenerate = True\n            elif args.list:\n                action = \"listing docker compose wiki applications\"\n            elif args.down:\n                action = \"running docker compose down\"\n            if not action:\n                parser.print_usage()\n            else:\n                print(f\"{action} for mediawiki versions {args.versions}\")\n                # create a MediaWiki Cluster\n                mwClusterConfig.fromArgs(args)\n                mwCluster = MediaWikiCluster(config=mwClusterConfig)\n                mwCluster.createApps(withGenerate=withGenerate)\n                if args.check:\n                    return mwCluster.check()\n                elif args.create:\n                    return mwCluster.start(forceRebuild=args.forceRebuild)\n                elif args.list:\n                    return mwCluster.listWikis()\n                elif args.down:\n                    return mwCluster.down(forceRebuild=args.forceRebuild)\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args is None:\n            print(\"args could not be parsed\")\n        elif args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#mwdocker.version","title":"<code>version</code>","text":"<p>Created on 2022-04-07</p> <p>@author: wf</p>"},{"location":"#mwdocker.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pymediawikidocker</p> Source code in <code>mwdocker/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pymediawikidocker\n    \"\"\"\n\n    name = \"pymediawikidocker\"\n    version = mwdocker.__version__\n    date = \"2021-06-21\"\n    updated = \"2024-04-19\"\n\n    authors = \"Wolfgang Fahl, Tim Holzheim\"\n\n    description = (\n        \"Python controlled (semantic) mediawiki docker application cluster installation\"\n    )\n\n    cm_url = \"https://github.com/WolfgangFahl/pymediawikidocker\"\n    chat_url = \"https://github.com/WolfgangFahl/pymediawikidocker/discussions\"\n    doc_url = \"https://wiki.bitplan.com/index.php/Pymediawikidocker\"\n\n    license = f\"\"\"Copyright 2020-2024 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#mwdocker.webscrape","title":"<code>webscrape</code>","text":"<p>Created on 2020-08-20</p> <p>@author: wf</p>"},{"location":"#mwdocker.webscrape.WebScrape","title":"<code>WebScrape</code>","text":"<p>               Bases: <code>object</code></p> <p>WebScraper</p> Source code in <code>mwdocker/webscrape.py</code> <pre><code>class WebScrape(object):\n    \"\"\"\n    WebScraper\n    \"\"\"\n\n    def __init__(self, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.err = None\n        self.valid = False\n        self.debug = debug\n        self.showHtml = showHtml\n\n    def getSoup(self, url, showHtml):\n        \"\"\"\n        get the beautiful Soup parser\n\n        Args:\n           showHtml(boolean): True if the html code should be pretty printed and shown\n        \"\"\"\n        req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n        html = urlopen(req).read()\n        soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n        if showHtml:\n            self.printPrettyHtml(soup)\n\n        return soup\n\n    def printPrettyHtml(self, soup):\n        \"\"\"\n        print the prettified html for the given soup\n\n        Args:\n            soup(BeuatifulSoup): the parsed html to print\n        \"\"\"\n        prettyHtml = soup.prettify()\n        print(prettyHtml)\n</code></pre>"},{"location":"#mwdocker.webscrape.WebScrape.__init__","title":"<code>__init__(debug=False, showHtml=False)</code>","text":"<p>Constructor</p> Source code in <code>mwdocker/webscrape.py</code> <pre><code>def __init__(self, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.err = None\n    self.valid = False\n    self.debug = debug\n    self.showHtml = showHtml\n</code></pre>"},{"location":"#mwdocker.webscrape.WebScrape.getSoup","title":"<code>getSoup(url, showHtml)</code>","text":"<p>get the beautiful Soup parser</p> <p>Parameters:</p> Name Type Description Default <code>showHtml(boolean)</code> <p>True if the html code should be pretty printed and shown</p> required Source code in <code>mwdocker/webscrape.py</code> <pre><code>def getSoup(self, url, showHtml):\n    \"\"\"\n    get the beautiful Soup parser\n\n    Args:\n       showHtml(boolean): True if the html code should be pretty printed and shown\n    \"\"\"\n    req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n    html = urlopen(req).read()\n    soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n    if showHtml:\n        self.printPrettyHtml(soup)\n\n    return soup\n</code></pre>"},{"location":"#mwdocker.webscrape.WebScrape.printPrettyHtml","title":"<code>printPrettyHtml(soup)</code>","text":"<p>print the prettified html for the given soup</p> <p>Parameters:</p> Name Type Description Default <code>soup(BeuatifulSoup)</code> <p>the parsed html to print</p> required Source code in <code>mwdocker/webscrape.py</code> <pre><code>def printPrettyHtml(self, soup):\n    \"\"\"\n    print the prettified html for the given soup\n\n    Args:\n        soup(BeuatifulSoup): the parsed html to print\n    \"\"\"\n    prettyHtml = soup.prettify()\n    print(prettyHtml)\n</code></pre>"}]}