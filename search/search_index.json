{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pymediawikidocker API Documentation","text":""},{"location":"#mwdocker.config","title":"<code>config</code>","text":"<p>Created on 2023-04-06</p> <p>@author: wf</p>"},{"location":"#mwdocker.config.Host","title":"<code>Host</code>","text":"<p>Host name getter</p> Source code in <code>mwdocker/config.py</code> <pre><code>class Host:\n    \"\"\"\n    Host name getter\n    \"\"\"\n\n    @classmethod\n    def get_default_host(cls) -&gt; str:\n        \"\"\"\n        Get the default host as a usable hostname or IP,\n        never returning reverse-DNS PTRs and avoiding localhost which\n        might cause to try socket access instead of proper host access\n        \"\"\"\n        host = socket.getfqdn()\n\n        # work around https://github.com/python/cpython/issues/79345\n        if host == (\n            \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\"\n        ):\n            host = \"127.0.0.1\"\n\n        elif host.endswith(\".in-addr.arpa\"):\n            host = \"127.0.0.1\"\n\n        elif host.endswith(\".ip6.arpa\"):\n            host = \"::1\"\n\n        elif host == \"localhost\":\n            host = \"127.0.0.1\"\n\n        return host\n</code></pre>"},{"location":"#mwdocker.config.Host.get_default_host","title":"<code>get_default_host()</code>  <code>classmethod</code>","text":"<p>Get the default host as a usable hostname or IP, never returning reverse-DNS PTRs and avoiding localhost which might cause to try socket access instead of proper host access</p> Source code in <code>mwdocker/config.py</code> <pre><code>@classmethod\ndef get_default_host(cls) -&gt; str:\n    \"\"\"\n    Get the default host as a usable hostname or IP,\n    never returning reverse-DNS PTRs and avoiding localhost which\n    might cause to try socket access instead of proper host access\n    \"\"\"\n    host = socket.getfqdn()\n\n    # work around https://github.com/python/cpython/issues/79345\n    if host == (\n        \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\"\n    ):\n        host = \"127.0.0.1\"\n\n    elif host.endswith(\".in-addr.arpa\"):\n        host = \"127.0.0.1\"\n\n    elif host.endswith(\".ip6.arpa\"):\n        host = \"::1\"\n\n    elif host == \"localhost\":\n        host = \"127.0.0.1\"\n\n    return host\n</code></pre>"},{"location":"#mwdocker.config.MwClusterConfig","title":"<code>MwClusterConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MwConfig</code></p> <p>MediaWiki Cluster configuration for multiple wikis</p> Source code in <code>mwdocker/config.py</code> <pre><code>@dataclass\nclass MwClusterConfig(MwConfig):\n    \"\"\"\n    MediaWiki Cluster configuration for multiple wikis\n    \"\"\"\n\n    versions: Optional[List[str]] = field(\n        default_factory=lambda: [\"1.35.13\", \"1.39.15\", \"1.43.5\", \"1.44.2\"]\n    )\n    base_port: int = 9080\n\n    def addArgs(self, parser):\n        \"\"\"\n        add my arguments to the given parser\n        \"\"\"\n        super().addArgs(parser)\n        parser.add_argument(\n            \"-bp\",\n            \"--base_port\",\n            dest=\"base_port\",\n            type=int,\n            default=self.base_port,\n            help=\"set how base html port 80 to be exposed - incrementing by one for each version [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-vl\",\n            \"--version_list\",\n            dest=\"versions\",\n            nargs=\"*\",\n            default=self.versions,\n            help=\"mediawiki versions to create docker applications for [default: %(default)s] \",\n        )\n\n    def fromArgs(self, args):\n        \"\"\"\n        initialize me from the given commmand line arguments\n\n        Args:\n            args(Namespace): the command line arguments\n        \"\"\"\n        dbc_name=args.db_container_name\n        if dbc_name:\n            env=DockerMap.getEnv(dbc_name)\n            self.mySQLRootPassword=env[\"MYSQL_ROOT_PASSWORD\"]\n            pass\n        super().fromArgs(args)\n</code></pre>"},{"location":"#mwdocker.config.MwClusterConfig.addArgs","title":"<code>addArgs(parser)</code>","text":"<p>add my arguments to the given parser</p> Source code in <code>mwdocker/config.py</code> <pre><code>def addArgs(self, parser):\n    \"\"\"\n    add my arguments to the given parser\n    \"\"\"\n    super().addArgs(parser)\n    parser.add_argument(\n        \"-bp\",\n        \"--base_port\",\n        dest=\"base_port\",\n        type=int,\n        default=self.base_port,\n        help=\"set how base html port 80 to be exposed - incrementing by one for each version [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-vl\",\n        \"--version_list\",\n        dest=\"versions\",\n        nargs=\"*\",\n        default=self.versions,\n        help=\"mediawiki versions to create docker applications for [default: %(default)s] \",\n    )\n</code></pre>"},{"location":"#mwdocker.config.MwClusterConfig.fromArgs","title":"<code>fromArgs(args)</code>","text":"<p>initialize me from the given commmand line arguments</p> <p>Parameters:</p> Name Type Description Default <code>args(Namespace)</code> <p>the command line arguments</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def fromArgs(self, args):\n    \"\"\"\n    initialize me from the given commmand line arguments\n\n    Args:\n        args(Namespace): the command line arguments\n    \"\"\"\n    dbc_name=args.db_container_name\n    if dbc_name:\n        env=DockerMap.getEnv(dbc_name)\n        self.mySQLRootPassword=env[\"MYSQL_ROOT_PASSWORD\"]\n        pass\n    super().fromArgs(args)\n</code></pre>"},{"location":"#mwdocker.config.MwConfig","title":"<code>MwConfig</code>","text":"<p>MediaWiki and docker configuration for a Single Wiki</p> Source code in <code>mwdocker/config.py</code> <pre><code>@lod_storable\nclass MwConfig:\n    \"\"\"\n    MediaWiki and docker configuration for a Single Wiki\n    \"\"\"\n    version: str = \"1.39.15\"\n    smw_version: Optional[str] = None\n    extensionNameList: Optional[List[str]] = field(\n        default_factory=lambda: [\n            \"Admin Links\",\n            \"Header Tabs\",\n            \"ParserFunctions\",\n            \"SyntaxHighlight\",\n            \"Variables\",\n        ]\n    )\n    extensionJsonFile: Optional[str] = None\n    user: str = \"Sysop\"\n    prefix: str = \"mw\"\n    logo: str = \"$wgResourceBasePath/resources/assets/wiki.png\"\n    url = None\n    full_url = None\n    prot: str = \"http\"\n    host: str = Host.get_default_host()\n    article_path: Optional[str] = None  # \"/index.php/$1\"\n    script_path: str = \"\"\n    wikiId: Optional[str] = None\n    # mysql settings\n    mySQLRootPassword: Optional[str] = None\n    mySQLPassword: Optional[str] = None\n    mariaDBVersion: str = \"11.8\"\n\n    # docker settings\n    bind_mount: bool = False\n    port: int = 9080\n    base_port: Optional[int] = None\n    sql_port: int = 9306\n    container_base_name: Optional[str] = None\n    # derived from container_base_name if different than default\n    # an external db_container is going to be used\n    db_container_name: Optional[str] = None\n    networkName: str = \"mwNetwork\"\n    docker_path: Optional[str] = None\n    gid: int = 33  # www-data\n    uid: int = 33  # www-data\n\n    # build control\n    verbose: bool = True\n    random_password: bool = False\n    force_user: bool = False\n    lenient: bool = True\n    password_length: int = 15\n    forceRebuild: bool = False\n    debug: bool = False\n    # FIXME - we should avoid a predefined known password\n    password: str = \"sysop-1234!\"\n\n    def default_docker_path(self) -&gt; str:\n        \"\"\"\n        get the default docker path\n\n        Returns:\n            str: $HOME/.pymediawikidocker\n        \"\"\"\n        home = str(Path.home())\n        docker_path = f\"{home}/.pymediawikidocker\"\n        return docker_path\n\n    def __post_init__(self):\n        \"\"\"\n        post initialization configuration\n        \"\"\"\n        self.fullVersion = f\"MediaWiki {self.version}\"\n        self.underscoreVersion = self.version.replace(\".\", \"_\")\n        self.shortVersion = self.getShortVersion()\n        if not self.docker_path:\n            self.docker_path = self.default_docker_path()\n        if not self.container_base_name:\n            self.container_base_name = f\"{self.prefix}-{self.shortVersion}\"\n        if not self.db_container_name:\n            self.db_container_name = f\"{self.container_base_name}-db\"\n        if not self.article_path:\n            self.article_path = \"\"\n        if not self.base_port:\n            self.base_port = self.port\n        self.reset_url(self.url)\n\n    @property\n    def has_external_db(self) -&gt; bool:\n        \"\"\"\n        Check if using external database container\n\n        Returns:\n            bool: True if db_container_name differs from default pattern\n        \"\"\"\n        default_db_name = f\"{self.container_base_name}-db\"\n        external= self.db_container_name != default_db_name\n        return external\n\n    def reset_url(self, url: str):\n        \"\"\"\n        reset my url\n\n        Args:\n            url(str): the url to set\n        \"\"\"\n        if url:\n            pr = urlparse(url)\n            self.prot = pr.scheme\n            self.host = pr.hostname\n            self.script_path = pr.path\n            self.base_url = f\"{self.prot}://{self.host}\"\n            self.full_url = url\n        else:\n            self.base_url = f\"{self.prot}://{self.host}:{self.base_port}\"\n\n            self.full_url = f\"{self.base_url}{self.script_path}\"\n\n    def reset_container_base_name(self, container_base_name: str=None):\n        \"\"\"\n        reset the container base name to the given name\n\n        Args:\n            container_base_name(str): the new container base name\n        \"\"\"\n        self.container_base_name = container_base_name\n        self.__post_init__()\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"\n        return my fields as a dict\n        dataclasses to dict conversion convenienc and information hiding\n\n        Returns:\n            dict: my fields in dict format\n        \"\"\"\n        config_dict = dataclasses.asdict(self)\n        return config_dict\n\n    def as_json(self) -&gt; str:\n        \"\"\"\n        return me as a json string\n\n        Returns:\n            str: my json representation\n        \"\"\"\n        config_dict = self.as_dict()\n        json_str = json.dumps(config_dict, indent=2)\n        return json_str\n\n    def get_config_path(self) -&gt; str:\n        \"\"\"\n        get my configuration base path\n\n        Returns:\n            str: the path to my configuration\n        \"\"\"\n        config_base_path = f\"{self.docker_path}/{self.container_base_name}\"\n        os.makedirs(config_base_path, exist_ok=True)\n        path = f\"{config_base_path}/MwConfig.json\"\n        return path\n\n    def save(self, path: str=None) -&gt; str:\n        \"\"\"\n        save my json\n\n        Args:\n            path(str): the path to store to - if None use {docker_path}/{container_base_name}/MwConfig.json\n        Returns:\n            str: the path\n        \"\"\"\n        if path is None:\n            path = self.get_config_path()\n\n        json_str = self.as_json()\n        with open(path, \"w\") as f:\n            print(json_str, file=f)\n        return path\n\n    def load(self, path: str=None) -&gt; \"MwConfig\":\n        \"\"\"\n        load the the MwConfig from the given path of if path is None (default)\n        use the config_path for the current configuration\n\n        restores the ExtensionMap on load\n\n        Args:\n            path(str): the path to load from\n\n        Returns:\n            MwConfig: a MediaWiki Configuration\n        \"\"\"\n        if path is None:\n            path = self.get_config_path()\n        with open(path, \"r\") as json_file:\n            json_str = json_file.read()\n            config = self.__class__.from_json(json_str)\n            # restore extension map\n            config.getExtensionMap(config.extensionNameList, config.extensionJsonFile)\n            return config\n\n    def getShortVersion(self, separator=\"\"):\n        \"\"\"\n        get my short version e.g. convert 1.27.7 to 127\n\n        Returns:\n            str: the short version string\n        \"\"\"\n        versionMatch = re.match(r\"(?P&lt;major&gt;[0-9]+)\\.(?P&lt;minor&gt;[0-9]+)\", self.version)\n        shortVersion = (\n            f\"{versionMatch.group('major')}{separator}{versionMatch.group('minor')}\"\n        )\n        return shortVersion\n\n    def create_random_password(self, length: int=15) -&gt; str:\n        \"\"\"\n        create a random password\n\n        Args:\n            length(int): the length of the password\n\n        Returns:\n            str:a random password with the given length\n        \"\"\"\n        random_password = secrets.token_urlsafe(length)\n        return random_password\n\n    def getWikiId(self):\n        \"\"\"\n        get the wikiId\n\n        Returns:\n            str: e.g. mw-9080\n        \"\"\"\n        if self.wikiId is None:\n            wikiId = f\"{self.prefix}-{self.port}\"\n        else:\n            wikiId = self.wikiId\n        return wikiId\n\n    def getExtensionMap(\n        self, extensionNameList: list=None, extensionJsonFile: str=None\n    ):\n        \"\"\"\n        get map of extensions to handle\n\n        Args:\n            extensionNameList (list): a list of extension names\n            extensionJsonFile (str): the name of an extra extensionJsonFile (if any)\n        \"\"\"\n        self.extensionMap = {}\n        extensionList = ExtensionList.restore()\n        self.extByName, duplicates = LOD.getLookup(extensionList.extensions, \"name\")\n        if len(duplicates) &gt; 0:\n            print(f\"{len(duplicates)} duplicate extensions: \")\n            for duplicate in duplicates:\n                print(duplicate.name)\n        if extensionJsonFile is not None:\n            extraExtensionList = ExtensionList.load_from_json_file(extensionJsonFile)  # @UndefinedVariable\n            for ext in extraExtensionList.extensions:\n                if ext.name in self.extByName:\n                    print(f\"overriding {ext.name} extension definition\")\n                self.extByName[ext.name] = ext\n        if extensionNameList is not None:\n            self.addExtensions(extensionNameList)\n        return self.extensionMap\n\n    def addExtensions(self, extensionNameList):\n        \"\"\"\n        add extensions for the given list of extension names\n        \"\"\"\n        for extensionName in extensionNameList:\n            if extensionName in self.extByName:\n                self.extensionMap[extensionName] = self.extByName[extensionName]\n            else:\n                print(f\"warning: extension {extensionName} not known\")\n\n    def fromArgs(self, args):\n        \"\"\"\n        initialize me from the given commmand line arguments\n\n        Args:\n            args(Namespace): the command line arguments\n        \"\"\"\n        self.prefix = args.prefix\n        self.article_path = args.article_path\n        self.container_base_name = args.container_name\n        self.db_container_name = args.db_container_name\n        self.docker_path = args.docker_path\n        self.extensionNameList = args.extensionNameList\n        self.extensionJsonFile = args.extensionJsonFile\n        self.bind_mount = args.bind_mount\n        self.uid = args.uid\n        self.gid = args.gid\n        self.forceRebuild = args.forceRebuild or getattr(args, \"force\", False)\n        self.host = args.host\n        self.logo = args.logo\n        self.mariaDBVersion = args.mariaDBVersion\n        # passwords\n        if args.mysqlRootPassword:\n            self.mySQLRootPassword = args.mysqlRootPassword\n        if not self.mySQLRootPassword:\n            if args.db_container_name:\n                # we need the password from the database container\n                pass\n            else:\n                self.mySQLRootPassword = self.create_random_password(self.password_length)\n        if args.mysqlPassword:\n            self.mySQLPassword = args.mysqlPassword\n        else:\n            self.mySQLPassword = self.create_random_password(self.password_length)\n        self.prot = args.prot\n        self.script_path = args.script_path\n        self.versions = args.versions\n        self.user = args.user\n        self.random_password = args.random_password\n        self.force_user = args.force_user\n        self.lenient = args.lenient\n        self.password = args.password\n        self.password_length = args.password_length\n        self.base_port = args.base_port\n        self.sql_port = args.sql_port\n        self.smw_version = args.smw_version\n        self.verbose = not args.quiet\n        self.debug = args.debug\n        self.getExtensionMap(self.extensionNameList, self.extensionJsonFile)\n        self.reset_url(args.url)\n\n    def addArgs(self, parser):\n        \"\"\"\n        add Arguments to the given parser\n        \"\"\"\n        parser.add_argument(\n            \"--article_path\",\n            default=self.article_path,\n            help=\"change to any article_path you might need to set [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-bm\",\n            \"--bind-mount\",\n            action=\"store_true\",\n            help=\"use bind mounts instead of volumes\",\n        )\n        parser.add_argument(\n            \"-cn\",\n            \"--container_name\",\n            default=self.container_base_name,\n            help=\"set container name (only valid and recommended for single version call)\",\n        )\n        parser.add_argument(\n            \"-dcn\",\n            \"--db_container_name\",\n            help=\"set database container name [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-el\",\n            \"--extensionList\",\n            dest=\"extensionNameList\",\n            nargs=\"*\",\n            default=self.extensionNameList,\n            help=\"list of extensions to be installed [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-ej\",\n            \"--extensionJson\",\n            dest=\"extensionJsonFile\",\n            default=self.extensionJsonFile,\n            help=\"additional extension descriptions default: [default: %(default)s]\",\n        )\n        # since -f is a default options we have to make sure we accept it as forceRebuild\n        parser.add_argument(\n            \"--forceRebuild\",\n            action=\"store_true\",\n            default=self.forceRebuild,\n            help=\"force rebuilding  [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-fu\",\n            \"--force_user\",\n            action=\"store_true\",\n            default=self.force_user,\n            help=\"force overwrite of wikiuser\",\n        )\n        parser.add_argument(\n            \"--host\",\n            default=Host.get_default_host(),\n            help=\"the host to serve / listen from [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-dp\",\n            \"--docker_path\",\n            default=self.default_docker_path(),\n            help=\"the base directory to store docker and jinja template files [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--lenient\",\n            action=\"store_true\",\n            help=\"do not throw error on wikiuser difference\",\n        )\n        parser.add_argument(\n            \"--logo\", default=self.logo, help=\"set Logo [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"-mv\",\n            \"--mariaDBVersion\",\n            dest=\"mariaDBVersion\",\n            default=self.mariaDBVersion,\n            help=\"mariaDB Version to be installed [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--mysqlRootPassword\",\n            default=self.mySQLRootPassword,\n            help=\"set sql root Password [default: %(default)s] - random password if None\",\n        )\n        parser.add_argument(\n            \"--mysqlPassword\",\n            default=self.mySQLPassword,\n            help=\"set sql user Password [default: %(default)s] - random password if None\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--random_password\",\n            action=\"store_true\",\n            default=self.random_password,\n            help=\"create random password and create wikiuser while at it\",\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--password\",\n            dest=\"password\",\n            default=self.password,\n            help=\"set password for initial user [default: %(default)s] \",\n        )\n        parser.add_argument(\n            \"-pl\",\n            \"--password_length\",\n            default=self.password_length,\n            help=\"set the password length for random passwords[default: %(default)s] \",\n        )\n        parser.add_argument(\n            \"--prefix\",\n            default=self.prefix,\n            help=\"the container name prefix to use [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--prot\",\n            default=self.prot,\n            help=\"change to https in case [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--script_path\",\n            default=self.script_path,\n            help=\"change to any script_path you might need to set [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--url\",\n            default=self.url,\n            help=\"will set prot host,script_path, and optionally port based on the url given [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-sp\",\n            \"--sql_base_port\",\n            dest=\"sql_port\",\n            type=int,\n            default=self.sql_port,\n            help=\"set base mySql port 3306 to be exposed - incrementing by one for each version [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-smw\",\n            \"--smw_version\",\n            dest=\"smw_version\",\n            default=self.smw_version,\n            help=\"set SemanticMediaWiki Version to be installed default is None - no installation of SMW\",\n        )\n        parser.add_argument(\n            \"-u\",\n            \"--user\",\n            dest=\"user\",\n            default=self.user,\n            help=\"set username of initial user with sysop rights [default: %(default)s] \",\n        )\n        parser.add_argument(\"--uid\", type=int, default=self.uid, help=\"User ID  (default: 33 for www-data)\")\n        parser.add_argument(\"--gid\", type=int, default=self.gid, help=\"Group ID (default: 33 for www-data)\")\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.has_external_db","title":"<code>has_external_db</code>  <code>property</code>","text":"<p>Check if using external database container</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if db_container_name differs from default pattern</p>"},{"location":"#mwdocker.config.MwConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>post initialization configuration</p> Source code in <code>mwdocker/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    post initialization configuration\n    \"\"\"\n    self.fullVersion = f\"MediaWiki {self.version}\"\n    self.underscoreVersion = self.version.replace(\".\", \"_\")\n    self.shortVersion = self.getShortVersion()\n    if not self.docker_path:\n        self.docker_path = self.default_docker_path()\n    if not self.container_base_name:\n        self.container_base_name = f\"{self.prefix}-{self.shortVersion}\"\n    if not self.db_container_name:\n        self.db_container_name = f\"{self.container_base_name}-db\"\n    if not self.article_path:\n        self.article_path = \"\"\n    if not self.base_port:\n        self.base_port = self.port\n    self.reset_url(self.url)\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.addArgs","title":"<code>addArgs(parser)</code>","text":"<p>add Arguments to the given parser</p> Source code in <code>mwdocker/config.py</code> <pre><code>def addArgs(self, parser):\n    \"\"\"\n    add Arguments to the given parser\n    \"\"\"\n    parser.add_argument(\n        \"--article_path\",\n        default=self.article_path,\n        help=\"change to any article_path you might need to set [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-bm\",\n        \"--bind-mount\",\n        action=\"store_true\",\n        help=\"use bind mounts instead of volumes\",\n    )\n    parser.add_argument(\n        \"-cn\",\n        \"--container_name\",\n        default=self.container_base_name,\n        help=\"set container name (only valid and recommended for single version call)\",\n    )\n    parser.add_argument(\n        \"-dcn\",\n        \"--db_container_name\",\n        help=\"set database container name [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-el\",\n        \"--extensionList\",\n        dest=\"extensionNameList\",\n        nargs=\"*\",\n        default=self.extensionNameList,\n        help=\"list of extensions to be installed [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-ej\",\n        \"--extensionJson\",\n        dest=\"extensionJsonFile\",\n        default=self.extensionJsonFile,\n        help=\"additional extension descriptions default: [default: %(default)s]\",\n    )\n    # since -f is a default options we have to make sure we accept it as forceRebuild\n    parser.add_argument(\n        \"--forceRebuild\",\n        action=\"store_true\",\n        default=self.forceRebuild,\n        help=\"force rebuilding  [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-fu\",\n        \"--force_user\",\n        action=\"store_true\",\n        default=self.force_user,\n        help=\"force overwrite of wikiuser\",\n    )\n    parser.add_argument(\n        \"--host\",\n        default=Host.get_default_host(),\n        help=\"the host to serve / listen from [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-dp\",\n        \"--docker_path\",\n        default=self.default_docker_path(),\n        help=\"the base directory to store docker and jinja template files [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--lenient\",\n        action=\"store_true\",\n        help=\"do not throw error on wikiuser difference\",\n    )\n    parser.add_argument(\n        \"--logo\", default=self.logo, help=\"set Logo [default: %(default)s]\"\n    )\n    parser.add_argument(\n        \"-mv\",\n        \"--mariaDBVersion\",\n        dest=\"mariaDBVersion\",\n        default=self.mariaDBVersion,\n        help=\"mariaDB Version to be installed [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--mysqlRootPassword\",\n        default=self.mySQLRootPassword,\n        help=\"set sql root Password [default: %(default)s] - random password if None\",\n    )\n    parser.add_argument(\n        \"--mysqlPassword\",\n        default=self.mySQLPassword,\n        help=\"set sql user Password [default: %(default)s] - random password if None\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--random_password\",\n        action=\"store_true\",\n        default=self.random_password,\n        help=\"create random password and create wikiuser while at it\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--password\",\n        dest=\"password\",\n        default=self.password,\n        help=\"set password for initial user [default: %(default)s] \",\n    )\n    parser.add_argument(\n        \"-pl\",\n        \"--password_length\",\n        default=self.password_length,\n        help=\"set the password length for random passwords[default: %(default)s] \",\n    )\n    parser.add_argument(\n        \"--prefix\",\n        default=self.prefix,\n        help=\"the container name prefix to use [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--prot\",\n        default=self.prot,\n        help=\"change to https in case [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--script_path\",\n        default=self.script_path,\n        help=\"change to any script_path you might need to set [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--url\",\n        default=self.url,\n        help=\"will set prot host,script_path, and optionally port based on the url given [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-sp\",\n        \"--sql_base_port\",\n        dest=\"sql_port\",\n        type=int,\n        default=self.sql_port,\n        help=\"set base mySql port 3306 to be exposed - incrementing by one for each version [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-smw\",\n        \"--smw_version\",\n        dest=\"smw_version\",\n        default=self.smw_version,\n        help=\"set SemanticMediaWiki Version to be installed default is None - no installation of SMW\",\n    )\n    parser.add_argument(\n        \"-u\",\n        \"--user\",\n        dest=\"user\",\n        default=self.user,\n        help=\"set username of initial user with sysop rights [default: %(default)s] \",\n    )\n    parser.add_argument(\"--uid\", type=int, default=self.uid, help=\"User ID  (default: 33 for www-data)\")\n    parser.add_argument(\"--gid\", type=int, default=self.gid, help=\"Group ID (default: 33 for www-data)\")\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.addExtensions","title":"<code>addExtensions(extensionNameList)</code>","text":"<p>add extensions for the given list of extension names</p> Source code in <code>mwdocker/config.py</code> <pre><code>def addExtensions(self, extensionNameList):\n    \"\"\"\n    add extensions for the given list of extension names\n    \"\"\"\n    for extensionName in extensionNameList:\n        if extensionName in self.extByName:\n            self.extensionMap[extensionName] = self.extByName[extensionName]\n        else:\n            print(f\"warning: extension {extensionName} not known\")\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.as_dict","title":"<code>as_dict()</code>","text":"<p>return my fields as a dict dataclasses to dict conversion convenienc and information hiding</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>my fields in dict format</p> Source code in <code>mwdocker/config.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"\n    return my fields as a dict\n    dataclasses to dict conversion convenienc and information hiding\n\n    Returns:\n        dict: my fields in dict format\n    \"\"\"\n    config_dict = dataclasses.asdict(self)\n    return config_dict\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.as_json","title":"<code>as_json()</code>","text":"<p>return me as a json string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>my json representation</p> Source code in <code>mwdocker/config.py</code> <pre><code>def as_json(self) -&gt; str:\n    \"\"\"\n    return me as a json string\n\n    Returns:\n        str: my json representation\n    \"\"\"\n    config_dict = self.as_dict()\n    json_str = json.dumps(config_dict, indent=2)\n    return json_str\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.create_random_password","title":"<code>create_random_password(length=15)</code>","text":"<p>create a random password</p> <p>Parameters:</p> Name Type Description Default <code>length(int)</code> <p>the length of the password</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a random password with the given length</p> Source code in <code>mwdocker/config.py</code> <pre><code>def create_random_password(self, length: int=15) -&gt; str:\n    \"\"\"\n    create a random password\n\n    Args:\n        length(int): the length of the password\n\n    Returns:\n        str:a random password with the given length\n    \"\"\"\n    random_password = secrets.token_urlsafe(length)\n    return random_password\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.default_docker_path","title":"<code>default_docker_path()</code>","text":"<p>get the default docker path</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>$HOME/.pymediawikidocker</p> Source code in <code>mwdocker/config.py</code> <pre><code>def default_docker_path(self) -&gt; str:\n    \"\"\"\n    get the default docker path\n\n    Returns:\n        str: $HOME/.pymediawikidocker\n    \"\"\"\n    home = str(Path.home())\n    docker_path = f\"{home}/.pymediawikidocker\"\n    return docker_path\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.fromArgs","title":"<code>fromArgs(args)</code>","text":"<p>initialize me from the given commmand line arguments</p> <p>Parameters:</p> Name Type Description Default <code>args(Namespace)</code> <p>the command line arguments</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def fromArgs(self, args):\n    \"\"\"\n    initialize me from the given commmand line arguments\n\n    Args:\n        args(Namespace): the command line arguments\n    \"\"\"\n    self.prefix = args.prefix\n    self.article_path = args.article_path\n    self.container_base_name = args.container_name\n    self.db_container_name = args.db_container_name\n    self.docker_path = args.docker_path\n    self.extensionNameList = args.extensionNameList\n    self.extensionJsonFile = args.extensionJsonFile\n    self.bind_mount = args.bind_mount\n    self.uid = args.uid\n    self.gid = args.gid\n    self.forceRebuild = args.forceRebuild or getattr(args, \"force\", False)\n    self.host = args.host\n    self.logo = args.logo\n    self.mariaDBVersion = args.mariaDBVersion\n    # passwords\n    if args.mysqlRootPassword:\n        self.mySQLRootPassword = args.mysqlRootPassword\n    if not self.mySQLRootPassword:\n        if args.db_container_name:\n            # we need the password from the database container\n            pass\n        else:\n            self.mySQLRootPassword = self.create_random_password(self.password_length)\n    if args.mysqlPassword:\n        self.mySQLPassword = args.mysqlPassword\n    else:\n        self.mySQLPassword = self.create_random_password(self.password_length)\n    self.prot = args.prot\n    self.script_path = args.script_path\n    self.versions = args.versions\n    self.user = args.user\n    self.random_password = args.random_password\n    self.force_user = args.force_user\n    self.lenient = args.lenient\n    self.password = args.password\n    self.password_length = args.password_length\n    self.base_port = args.base_port\n    self.sql_port = args.sql_port\n    self.smw_version = args.smw_version\n    self.verbose = not args.quiet\n    self.debug = args.debug\n    self.getExtensionMap(self.extensionNameList, self.extensionJsonFile)\n    self.reset_url(args.url)\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.getExtensionMap","title":"<code>getExtensionMap(extensionNameList=None, extensionJsonFile=None)</code>","text":"<p>get map of extensions to handle</p> <p>Parameters:</p> Name Type Description Default <code>extensionNameList</code> <code>list</code> <p>a list of extension names</p> <code>None</code> <code>extensionJsonFile</code> <code>str</code> <p>the name of an extra extensionJsonFile (if any)</p> <code>None</code> Source code in <code>mwdocker/config.py</code> <pre><code>def getExtensionMap(\n    self, extensionNameList: list=None, extensionJsonFile: str=None\n):\n    \"\"\"\n    get map of extensions to handle\n\n    Args:\n        extensionNameList (list): a list of extension names\n        extensionJsonFile (str): the name of an extra extensionJsonFile (if any)\n    \"\"\"\n    self.extensionMap = {}\n    extensionList = ExtensionList.restore()\n    self.extByName, duplicates = LOD.getLookup(extensionList.extensions, \"name\")\n    if len(duplicates) &gt; 0:\n        print(f\"{len(duplicates)} duplicate extensions: \")\n        for duplicate in duplicates:\n            print(duplicate.name)\n    if extensionJsonFile is not None:\n        extraExtensionList = ExtensionList.load_from_json_file(extensionJsonFile)  # @UndefinedVariable\n        for ext in extraExtensionList.extensions:\n            if ext.name in self.extByName:\n                print(f\"overriding {ext.name} extension definition\")\n            self.extByName[ext.name] = ext\n    if extensionNameList is not None:\n        self.addExtensions(extensionNameList)\n    return self.extensionMap\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.getShortVersion","title":"<code>getShortVersion(separator='')</code>","text":"<p>get my short version e.g. convert 1.27.7 to 127</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the short version string</p> Source code in <code>mwdocker/config.py</code> <pre><code>def getShortVersion(self, separator=\"\"):\n    \"\"\"\n    get my short version e.g. convert 1.27.7 to 127\n\n    Returns:\n        str: the short version string\n    \"\"\"\n    versionMatch = re.match(r\"(?P&lt;major&gt;[0-9]+)\\.(?P&lt;minor&gt;[0-9]+)\", self.version)\n    shortVersion = (\n        f\"{versionMatch.group('major')}{separator}{versionMatch.group('minor')}\"\n    )\n    return shortVersion\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.getWikiId","title":"<code>getWikiId()</code>","text":"<p>get the wikiId</p> <p>Returns:</p> Name Type Description <code>str</code> <p>e.g. mw-9080</p> Source code in <code>mwdocker/config.py</code> <pre><code>def getWikiId(self):\n    \"\"\"\n    get the wikiId\n\n    Returns:\n        str: e.g. mw-9080\n    \"\"\"\n    if self.wikiId is None:\n        wikiId = f\"{self.prefix}-{self.port}\"\n    else:\n        wikiId = self.wikiId\n    return wikiId\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.get_config_path","title":"<code>get_config_path()</code>","text":"<p>get my configuration base path</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to my configuration</p> Source code in <code>mwdocker/config.py</code> <pre><code>def get_config_path(self) -&gt; str:\n    \"\"\"\n    get my configuration base path\n\n    Returns:\n        str: the path to my configuration\n    \"\"\"\n    config_base_path = f\"{self.docker_path}/{self.container_base_name}\"\n    os.makedirs(config_base_path, exist_ok=True)\n    path = f\"{config_base_path}/MwConfig.json\"\n    return path\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.load","title":"<code>load(path=None)</code>","text":"<p>load the the MwConfig from the given path of if path is None (default) use the config_path for the current configuration</p> <p>restores the ExtensionMap on load</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to load from</p> required <p>Returns:</p> Name Type Description <code>MwConfig</code> <code>MwConfig</code> <p>a MediaWiki Configuration</p> Source code in <code>mwdocker/config.py</code> <pre><code>def load(self, path: str=None) -&gt; \"MwConfig\":\n    \"\"\"\n    load the the MwConfig from the given path of if path is None (default)\n    use the config_path for the current configuration\n\n    restores the ExtensionMap on load\n\n    Args:\n        path(str): the path to load from\n\n    Returns:\n        MwConfig: a MediaWiki Configuration\n    \"\"\"\n    if path is None:\n        path = self.get_config_path()\n    with open(path, \"r\") as json_file:\n        json_str = json_file.read()\n        config = self.__class__.from_json(json_str)\n        # restore extension map\n        config.getExtensionMap(config.extensionNameList, config.extensionJsonFile)\n        return config\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.reset_container_base_name","title":"<code>reset_container_base_name(container_base_name=None)</code>","text":"<p>reset the container base name to the given name</p> <p>Parameters:</p> Name Type Description Default <code>container_base_name(str)</code> <p>the new container base name</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def reset_container_base_name(self, container_base_name: str=None):\n    \"\"\"\n    reset the container base name to the given name\n\n    Args:\n        container_base_name(str): the new container base name\n    \"\"\"\n    self.container_base_name = container_base_name\n    self.__post_init__()\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.reset_url","title":"<code>reset_url(url)</code>","text":"<p>reset my url</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to set</p> required Source code in <code>mwdocker/config.py</code> <pre><code>def reset_url(self, url: str):\n    \"\"\"\n    reset my url\n\n    Args:\n        url(str): the url to set\n    \"\"\"\n    if url:\n        pr = urlparse(url)\n        self.prot = pr.scheme\n        self.host = pr.hostname\n        self.script_path = pr.path\n        self.base_url = f\"{self.prot}://{self.host}\"\n        self.full_url = url\n    else:\n        self.base_url = f\"{self.prot}://{self.host}:{self.base_port}\"\n\n        self.full_url = f\"{self.base_url}{self.script_path}\"\n</code></pre>"},{"location":"#mwdocker.config.MwConfig.save","title":"<code>save(path=None)</code>","text":"<p>save my json</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to store to - if None use {docker_path}/{container_base_name}/MwConfig.json</p> required <p>Returns:     str: the path</p> Source code in <code>mwdocker/config.py</code> <pre><code>def save(self, path: str=None) -&gt; str:\n    \"\"\"\n    save my json\n\n    Args:\n        path(str): the path to store to - if None use {docker_path}/{container_base_name}/MwConfig.json\n    Returns:\n        str: the path\n    \"\"\"\n    if path is None:\n        path = self.get_config_path()\n\n    json_str = self.as_json()\n    with open(path, \"w\") as f:\n        print(json_str, file=f)\n    return path\n</code></pre>"},{"location":"#mwdocker.docker","title":"<code>docker</code>","text":"<p>Created on 2021-08-06</p> <p>@author: wf</p>"},{"location":"#mwdocker.docker.DBStatus","title":"<code>DBStatus</code>  <code>dataclass</code>","text":"<p>the Database Status</p> Source code in <code>mwdocker/docker.py</code> <pre><code>@dataclass\nclass DBStatus:\n    \"\"\"\n    the Database Status\n    \"\"\"\n\n    attempts: int\n    max_tries: int\n    ok: bool\n    msg: str\n    ex: typing.Optional[Exception] = None\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication","title":"<code>DockerApplication</code>","text":"<p>               Bases: <code>object</code></p> <p>MediaWiki Docker image</p> Source code in <code>mwdocker/docker.py</code> <pre><code>class DockerApplication(object):\n    \"\"\"\n    MediaWiki Docker image\n    \"\"\"\n\n    def __init__(self, config: MwClusterConfig):\n        \"\"\"\n        Constructor\n\n        Args:\n            config: MwClusterConfig,\n            home: the home directory to use\n        \"\"\"\n        self.config = config\n        # branch as need for git clone e.g. https://gerrit.wikimedia.org/g/mediawiki/extensions/MagicNoCache\n        self.branch = f\"REL{self.config.getShortVersion('_')}\"\n        self.composerVersion = 1\n        if self.config.shortVersion &gt;= \"139\":\n            self.composerVersion = 2\n        # jinja and docker prerequisites\n        self.env = self.getJinjaEnv()\n        # docker file location\n        self.docker_path = (\n            f\"{self.config.docker_path}/{self.config.container_base_name}\"\n        )\n        os.makedirs(self.docker_path, exist_ok=True)\n\n        self.getContainers()\n        self.dbConn = None\n        self.wiki_id=self.config.getWikiId()\n        self.database = f\"{self.wiki_id}_wiki\"\n        self.dbUser = f\"{self.wiki_id}_user\"\n        self.wikiUser = None\n        # Hook to allow modifying results\n        # e.g. docker-compose.yaml after generation is finished\n        self.postgen_hook = None\n\n    @staticmethod\n    def checkDockerEnvironment(debug: bool = False) -&gt; str:\n        \"\"\"\n        check the docker environment\n\n        Args:\n            debug (bool): if True show debug information\n\n        Returns:\n            str: an error message or None\n        \"\"\"\n        errMsg = None\n        os_path = os.environ[\"PATH\"]\n        paths = [\"/usr/local/bin\"]\n        for path in paths:\n            if os.path.islink(f\"{path}/docker\"):\n                if not path in os_path:\n                    os.environ[\"PATH\"] = f\"{os_path}{os.pathsep}{path}\"\n                    if debug:\n                        print(\n                            f\"\"\"modified PATH from {os_path} to \\n{os.environ[\"PATH\"]}\"\"\"\n                        )\n        if not docker.compose.is_installed():\n            errMsg = \"\"\"docker compose up needs to be working\"\"\"\n\n        return errMsg\n\n    def get_version_url(self, host_port: str) -&gt; str:\n        \"\"\"\n        get the Special:Version url\n        \"\"\"\n        url = self.config.full_url\n        # fix url to local port\n        # @TODO isn't this superfluous / has no effect ...?\n        url = url.replace(str(self.config.port), host_port)\n        version_url = f\"{url}/index.php?title=Special:Version\"\n        return version_url\n\n    def check(self) -&gt; int:\n        \"\"\"\n        check me\n\n        Returns:\n            int: exitCode: 0 if ok, 1 if not ok\n        \"\"\"\n        DockerApplication.checkDockerEnvironment(self.config.debug)\n        exitCode = 0\n        mw, db = self.getContainers()\n        if not mw:\n            print(\"mediawiki container missing\")\n            exitCode = 1\n        if not db:\n            print(\"database container missing\")\n            exitCode = 1\n        if mw and db and mw.check() and db.check():\n            host_port = mw.getHostPort(80)\n            if host_port:\n                Logger.check_and_log_equal(\n                    f\"port binding\", host_port, \"expected  port\", str(self.config.port)\n                )\n                version_url = self.get_version_url(host_port)\n                ok = self.checkWiki(version_url)\n                if not ok:\n                    exitCode = 1\n            else:\n                self.log(f\"port binding for port 80 missing\", False)\n                exitCode = 1\n            pass\n        return exitCode\n\n    def checkWiki(self, version_url: str) -&gt; bool:\n        \"\"\"\n        check this wiki against the content of the given version_url\n        \"\"\"\n        print(f\"Checking {version_url} ...\")\n        ok = True\n        try:\n            html_tables = HtmlTables(version_url)\n            tables = html_tables.get_tables(\"h2\")\n            if self.config.debug:\n                p = pprint.PrettyPrinter(indent=2)\n                p.pprint(tables)\n            ok = ok and Logger.check_and_log(\n                \"Special Version accessible ...\", \"Installed software\" in tables\n            )\n            if ok:\n                software = tables[\"Installed software\"]\n                software_map, _dup = LOD.getLookup(\n                    software, \"Product\", withDuplicates=False\n                )\n                mw_version = software_map[\"MediaWiki\"][\"Version\"]\n                ok = ok and Logger.check_and_log_equal(\n                    \"Mediawiki Version\", mw_version, \"expected \", self.config.version\n                )\n                db_version_str = software_map[\"MariaDB\"][\"Version\"]\n                db_version = MariaDB.getVersion(db_version_str)\n                ok = ok and Logger.check_and_log(\n                    f\"Maria DB Version {db_version} fitting expected {self.config.mariaDBVersion}?\",\n                    self.config.mariaDBVersion.startswith(db_version),\n                )\n                pass\n        except Exception as ex:\n            ok = Logger.check_and_log(str(ex), False)\n        return ok\n\n    def getContainerName(self, kind: str, separator: str):\n        \"\"\"\n        get my container Name\n        \"\"\"\n        containerName = f\"{self.config.container_base_name}{separator}{kind}\"\n        return containerName\n\n    def getContainers(self):\n        \"\"\"\n        get my containers\n\n        Returns:\n            Tuple(\n        \"\"\"\n        self.dbContainer = None\n        self.mwContainer = None\n        containerMap = DockerMap.getContainerMap()\n        for separator in [\"-\", \"_\"]:\n            dbContainerName = self.getContainerName(\"db\", separator)\n            mwContainerName = self.getContainerName(\"mw\", separator)\n            if dbContainerName in containerMap:\n                self.dbContainer = DockerContainer(\n                    dbContainerName, \"database\", containerMap[dbContainerName]\n                )\n            if mwContainerName in containerMap:\n                self.mwContainer = DockerContainer(\n                    mwContainerName, \"webserver\", containerMap[mwContainerName]\n                )\n        return self.mwContainer, self.dbContainer\n\n    def getJinjaEnv(self):\n        \"\"\"\n        get a Jinja2 environment\n        \"\"\"\n        scriptdir = os.path.dirname(os.path.realpath(__file__))\n        resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n        template_dir = os.path.realpath(f\"{resourcePath}/templates\")\n        # print(f\"jinja template directory is {template_dir}\")\n        env = Environment(loader=FileSystemLoader(template_dir))\n        return env\n\n    def createWikiUser(self, wikiId: str = None, store: bool = False):\n        \"\"\"\n        create my wikiUser and optionally save it\n\n        Args:\n           store (bool): if True save my user data to the relevant ini File\n        \"\"\"\n        if not wikiId:\n            wikiId = f\"{self.config.container_base_name}\"\n        userDict = {\n            \"wikiId\": f\"{wikiId}\",\n            \"url\": f\"{self.config.base_url}:{self.config.port}\",\n            \"scriptPath\": f\"{self.config.script_path}\",\n            \"user\": f\"{self.config.user}\",\n            \"email\": \"noreply@nouser.com\",\n            \"version\": f\"{self.config.fullVersion}\",\n            \"password\": f\"{self.config.password}\",\n        }\n        wikiUser = WikiUser.ofDict(userDict, encrypted=False)\n        if store:\n            wikiUser.save()\n        return wikiUser\n\n    def createOrModifyWikiUser(\n        self, wikiId, force_overwrite: bool = False, lenient: bool = False\n    ) -&gt; WikiUser:\n        \"\"\"\n        create or modify the WikiUser for this DockerApplication\n\n        Args:\n            wikiId (str): the wikiId to create or modify a wiki user for\n            force_overwrite (bool): if True overwrite the wikiuser info\n            lenient(bool): do not throw Exception if wikiuser exists\n        \"\"\"\n        wikiUsers = WikiUser.getWikiUsers(lenient=True)\n        if wikiId in wikiUsers and not force_overwrite:\n            wikiUser = wikiUsers[wikiId]\n            if self.config.password != wikiUser.getPassword():\n                msg = f\"wikiUser for wiki {wikiId} already exists but with different password\"\n                if lenient:\n                    print(msg, file=sys.stderr)\n                else:\n                    raise Exception(msg)\n            pass\n        else:\n            wikiUser = self.createWikiUser(wikiId, store=True)\n        return wikiUser\n\n    def execute(self, *commands: str):\n        \"\"\"\n        Execute the given variable list of command strings inside the MediaWiki container.\n\n        Args:\n            commands: str - command parts to be executed\n        \"\"\"\n        if not self.mwContainer:\n            mwContainerNameDash = self.getContainerName(\"mw\", \"-\")\n            mwContainerNameUnderscore = self.getContainerName(\"mw\", \"_\")\n            raise Exception(\n              f\"no mediawiki Container {mwContainerNameDash} or {mwContainerNameUnderscore} for {self.name} \"\n              f\"activated by docker compose\\n- you might want to check the separator character used \"\n              f\"for container names for your platform {platform.system()}\"\n            )\n        self.mwContainer.execute(*commands,verbose=self.config.verbose)\n\n    def close(self):\n        \"\"\"\n        close the database\n        \"\"\"\n        self.dbClose()\n\n    def sqlQuery(self, query):\n        \"\"\"\n        run the given SQL query\n        \"\"\"\n        if self.dbConn and self.dbConn.is_connected():\n            cursor = self.dbConn.cursor()\n            cursor.execute(query)\n            rows = cursor.fetchall()\n            cursor.close()\n            return rows\n        else:\n            if self.config.verbose:\n                print(\n                    f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} not established\"\n                )\n            return None\n\n    def dbClose(self):\n        \"\"\"\n        close the database connection\n        \"\"\"\n        if self.dbConn and self.dbConn.is_connected():\n            self.dbConn.close()\n\n    def dbConnect(self, timeout: int = 10):\n        \"\"\"\n        connect to the database and return the connection\n\n        Args:\n            timeout (int): number of seconds for timeout\n\n        Returns:\n            the connection\n        \"\"\"\n        if self.dbConn is None:\n            try:\n                self.dbConn = mysql.connector.connect(\n                    host=self.config.host,\n                    database=self.database,\n                    user=self.dbUser,\n                    port=self.config.sql_port,\n                    password=self.config.mySQLPassword,\n                    connection_timeout=timeout,\n                )\n\n            except Error as e:\n                errMsg = str(e)\n                print(\n                    f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} failed error: {errMsg}\"\n                )\n                if \"Access denied\" in errMsg:\n                    raise e\n        return self.dbConn\n\n    def doCheckDBConnection(self, dbStatus: DBStatus, timeout: int = 10):\n        \"\"\"\n        check the database connection of this application\n\n        Args:\n            timeout (int): how many seconds to wait\n\n        Returns:\n            DBStatus\n        \"\"\"\n        dbStatus.attempts += 1\n        self.dbConnect(timeout=timeout)\n        if self.dbConn and self.dbConn.is_connected():\n            rows = self.sqlQuery(\"select database();\")\n            dbStatus.ok = True\n            if self.config.verbose:\n                print(f\"{dbStatus.msg} established database returns: {rows[0]}\")\n\n    def checkDBConnection(\n        self,\n        timeout: float = 10,\n        initialSleep: float = 4.0,\n        factor=1.5,\n        maxTries: int = 9,\n    ) -&gt; DBStatus:\n        \"\"\"\n        check database connection with retries\n\n        Args:\n            timeout (float): number of seconds for timeout\n            initialSleep (float): number of seconds to initially wait/sleep\n            maxTries (int): maximum number of retries before giving up between each try a sleep is done that starts\n            with 0.5 secs and multiplies on every retry\n\n        Returns:\n            dbStatus: the status\n        \"\"\"\n        conn_msg = f\"SQL-Connection to {self.database} on {self.config.host} port {self.config.sql_port} with user {self.dbUser}\"\n        dbStatus = DBStatus(attempts=0, ok=False, msg=conn_msg, max_tries=maxTries)\n        if self.config.verbose:\n            print(\n                f\"Trying {dbStatus.msg} with max {maxTries} tries and {timeout}s timeout per try - initial sleep {initialSleep}s\"\n            )\n        time.sleep(initialSleep)\n        sleep = 2.0\n        while not dbStatus.ok and dbStatus.attempts &lt;= maxTries:\n            try:\n                self.doCheckDBConnection(dbStatus, timeout=timeout)\n                if not dbStatus.ok:\n                    if self.config.verbose:\n                        print(\n                            f\"Connection attempt #{dbStatus.attempts}/{dbStatus.max_tries} failed will retry in {sleep:4.1f} secs\"\n                        )\n                    # wait before trying\n                    time.sleep(sleep)\n                    sleep = sleep * factor\n            except Exception as ex:\n                dbStatus.ex = ex\n                if self.config.verbose:\n                    print(\n                        f\"Connection attempt #{dbStatus.attempts} failed with exception {str(ex)} - will not retry ...\"\n                    )\n                if self.config.debug:\n                    print(traceback.format_exc())\n                break\n        return dbStatus\n\n    def optionalWrite(self, targetPath: str, content: str, overwrite: bool = False):\n        \"\"\"\n        optionally Write the modified content to the given targetPath\n\n        Args:\n            targetPath (str): the path to write the content to\n            content (str): the content to write\n            overwrite (bool): if True overwrite the existing content\n        \"\"\"\n        if not overwrite and os.path.isfile(targetPath):\n            if self.config.verbose:\n                print(f\"{targetPath} already exists!\")\n            return\n        with open(targetPath, \"w\", newline=\"\") as targetFile:\n            targetFile.write(content)\n\n    def generate(\n        self, templateName: str, targetPath: str, overwrite: bool = False, **kwArgs\n    ):\n        \"\"\"\n        generate file at targetPath using the given templateName\n\n        Args:\n            templateName (str): the Jinja2 template to use\n            targetPath (str): the path to the target file\n            overwrite (bool): if True overwrite existing files\n            kwArgs(): generic keyword arguments to pass on to template rendering\n        \"\"\"\n        try:\n            template = self.env.get_template(templateName)\n            timestamp = datetime.datetime.now().isoformat()\n            content = template.render(\n                mwVersion=self.config.version,\n                mariaDBVersion=self.config.mariaDBVersion,\n                port=self.config.port,\n                sql_port=self.config.sql_port,\n                smw_version=self.config.smw_version,\n                timestamp=timestamp,\n                pmwdVersion=Version.version,\n                config=self.config,\n                **kwArgs,\n            )\n            self.optionalWrite(targetPath, content, overwrite)\n\n        except TemplateNotFound:\n            print(f\"no template {templateName} for {self.config.version}\")\n\n    def getComposerRequire(self):\n        \"\"\"\n        get the json string for the composer require e.g. composer.local.json\n        \"\"\"\n        requires = []\n        for ext in self.config.extensionMap.values():\n            # get the composer statement\n            if ext.composer:\n                requires.append(ext.composer)\n        indent = \"     \"\n        delim = \"\" if len(requires) == 0 else \",\\n\"\n        requireList = \"\"\n        if self.config.smw_version:\n            requireList += f'{indent}\"mediawiki/semantic-media-wiki\": \"~{self.config.smw_version}\"{delim}'\n        for i, require in enumerate(requires):\n            delim = \"\" if i &gt;= len(requires) - 1 else \",\\n\"\n            requireList += f\"{indent}{require}{delim}\"\n        requireJson = f\"\"\"{{\n  \"require\": {{\n{requireList}\n  }}\n}}\"\"\"\n        return requireJson\n\n    def genComposerRequire(self, composerFilePath, overwrite: bool = False):\n        \"\"\"\n        gen the composer.local.json require file\n\n        Args:\n            composerFilePath (str): the name of the file to generate\n        \"\"\"\n        requireJson = self.getComposerRequire()\n        self.optionalWrite(composerFilePath, requireJson, overwrite)\n\n    def generateAll(self, overwrite: bool = False):\n        \"\"\"\n        generate all files needed for the docker handling\n\n        Args:\n            overwrite (bool): if True overwrite the existing files\n        \"\"\"\n        # make sure we have the wiki_id ready\n        wiki_id=self.config.getWikiId()\n        # we have to configure whether\n        # bind mounts or volumes are to be used\n        if self.config.bind_mount:\n            volume_type = \"bind\"\n            mysql_data = f\"/var/lib/mediawiki/mysql/{self.config.shortVersion}\"\n            wiki_sites = f\"/var/www/mediawiki/sites\"\n        else:\n            volume_type = \"volume\"\n            mysql_data = \"mysql-data\"\n            wiki_sites = \"wiki-sites\"\n        # first generate Dockerfile\n        # the goal is to get an empty MediaWiki (no LocalSettings/extensions)\n        # with composer ready\n        self.generate(\n            \"mwDockerfile\",\n            f\"{self.docker_path}/Dockerfile\",\n            composerVersion=self.composerVersion,\n            volume_type=volume_type,\n            overwrite=overwrite,\n        )\n        # the master setup script\n        # this used to be part of Dockerfile but\n        # needs to be scripted when we use bind mounts due\n        # to docker's poor design of permission and mount handling\n        self.generate(\n            f\"setup-mediawiki.sh\",\n            f\"{self.docker_path}/setup-mediawiki.sh\",\n            script_dir=\"/scripts\",\n            web_dir=\"/var/www/html\",\n            overwrite=overwrite,\n        )\n        # the Docker compose\n        # at this stage we will have two containers\n        # one for the database and one for the MediaWiki\n        # the db container may be optionally an existing database container\n        template_name = \"mwComposeExternalDB.yml\" if self.config.has_external_db else \"mwCompose.yml\"\n        self.generate(\n            template_name,\n            f\"{self.docker_path}/docker-compose.yml\",\n            # might be None for ExternalDB case\n            mySQLRootPassword=self.config.mySQLRootPassword,\n            mySQLPassword=self.config.mySQLPassword,\n            container_base_name=self.config.container_base_name,\n            db_container_name=self.config.db_container_name,\n            wiki_id=wiki_id,\n            volume_type=volume_type,\n            mysql_data=mysql_data,\n            wiki_sites=wiki_sites,\n            scripts_dir=self.docker_path,\n            uid=self.config.uid,\n            gid=self.config.gid,\n            overwrite=overwrite,\n        )\n        # now generate the parts we will use later to\n        # create the fully configured wiki\n        # first - LocalSettings with references to all extensions\n        self.generate(\n            f\"mwLocalSettings{self.config.shortVersion}.php\",\n            f\"{self.docker_path}/LocalSettings.php\",\n            wiki_id=wiki_id,\n            mySQLPassword=self.config.mySQLPassword,\n            hostname=self.config.host,\n            extensions=self.config.extensionMap.values(),\n            mwShortVersion=self.config.shortVersion,\n            logo=self.config.logo,\n            overwrite=overwrite,\n        )\n        # the SQL file for initial content\n        self.generate(\n            f\"mwWiki{self.config.shortVersion}.sql\",\n            f\"{self.docker_path}/wiki.sql\",\n            overwrite=overwrite,\n        )\n        # a WikiUser for automated access via\n        # py-3rdparty mediawiki\n        if self.config.random_password:\n            self.config.password = self.config.create_random_password(\n                length=self.config.password_length\n            )\n            if self.config.wikiId:\n                self.createOrModifyWikiUser(\n                    self.config.wikiId,\n                    force_overwrite=self.config.force_user,\n                    lenient=self.config.lenient,\n                )\n        self.generate(\n            f\"addSysopUser.sh\",\n            f\"{self.docker_path}/addSysopUser.sh\",\n            user=self.config.user,\n            password=self.config.password,\n            overwrite=overwrite,\n        )\n        self.generate(\n            f\"installExtensions.sh\",\n            f\"{self.docker_path}/installExtensions.sh\",\n            extensions=self.config.extensionMap.values(),\n            branch=self.branch,\n            overwrite=overwrite,\n        )\n        self.genComposerRequire(\n            f\"{self.docker_path}/composer.local.json\", overwrite=overwrite\n        )\n        for file_name in [\n            \"phpinfo.php\",\n            \"disable_sudo.sh\",\n            \"install_djvu.sh\",\n            \"plantuml.sh\",\n            \"upload.ini\",\n        ]:\n            self.generate(\n                f\"{file_name}\", f\"{self.docker_path}/{file_name}\", overwrite=overwrite\n            )\n\n        # chmod generated scripts that need to be bash callable\n        # to be executable on container operating system (linux)\n        # when bind mounted or being copied\n        for executable in [\n            \"disable_sudo.sh\",\n            \"install_djvu.sh\",\n            \"plantuml.sh\",\n            \"addSysopUser.sh\",\n            \"installExtensions.sh\",\n            \"setup-mediawiki.sh\",\n        ]:\n            path = os.path.join(self.docker_path, executable)\n            if os.path.exists(path):\n                st = os.stat(path)\n                os.chmod(path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)\n\n        if self.postgen_hook:\n            self.postgen_hook(self)\n\n        # remember the configuration we used for generating\n        # avoid endless loop - forceRebuilds - we have rebuild already\n        forceRebuild = self.config.forceRebuild\n        self.config.forceRebuild = False\n        self.config.save()\n        self.config.forceRebuild = forceRebuild\n\n    def down(self, forceRebuild: bool = False):\n        \"\"\"\n        run docker compose down\n\n        see https://docs.docker.com/engine/reference/commandline/compose_down/\n        and https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/compose/#down\n\n        \"\"\"\n        DockerApplication.checkDockerEnvironment(self.config.debug)\n        # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n        if self.config.verbose:\n            print(\n                f\"running docker compose down for {self.config.container_base_name} {self.config.version} docker application ...\"\n            )\n        # remember current directory\n        cwd = os.getcwd()\n        os.chdir(self.docker_path)\n        try:\n            docker.compose.down(volumes=forceRebuild)\n        except DockerException as dex:\n            print(f\"warning: docker compose down failed in {self.docker_path}:{str(dex)}\")\n            pass\n        # switch back to previous current directory\n        os.chdir(cwd)\n\n    def up(self, forceRebuild: bool = False):\n        \"\"\"\n        start this docker application\n\n        Args:\n            forceRebuild (bool): if true stop and remove the existing containers\n        \"\"\"\n        DockerApplication.checkDockerEnvironment(self.config.debug)\n        if self.config.verbose:\n            print(\n                f\"starting {self.config.container_base_name} {self.config.version} docker application ...\"\n            )\n        if forceRebuild:\n            for docker_container in [self.dbContainer, self.mwContainer]:\n                if docker_container is not None:\n                    container = docker_container.container\n                    try:\n                        container_name = container.name\n                        if self.config.verbose:\n                            print(f\"stopping and removing container {container_name}\")\n                    except Exception as container_ex:\n                        container = None\n                    if container:\n                        try:\n                            container.stop()\n                        except Exception as stop_ex:\n                            if self.config.verbose:\n                                print(f\"stop failed with {str(stop_ex)}\")\n                            pass\n                        try:\n                            container.remove()\n                        except Exception as remove_ex:\n                            if self.config.verbose:\n                                print(f\"removed failed with {str(remove_ex)}\")\n                            pass\n                    pass\n\n        # remember current directory\n        cwd = os.getcwd()\n\n        # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n        os.chdir(self.docker_path)\n        # project_config = docker.compose.config()\n        if forceRebuild:\n            docker.compose.build()\n        # run docker compose up\n        # this might take a while e.g. downloading\n        # run docker compose up\n        try:\n            docker.compose.up(detach=True, force_recreate=forceRebuild)\n        except Exception as de:\n            print(f\"docker compose up failed in {self.docker_path}\")\n            raise de\n            pass\n        # switch back to previous current directory\n        os.chdir(cwd)\n\n        # check the startup of both containers\n        mw, db = self.getContainers()\n        for dc in [mw, db]:\n            if dc:\n                start_secs = dc.wait_for_state(running=True)\n                if self.config.verbose:\n                    print(f\"{dc.name} \ud83d\udfe2 started in {start_secs:.2f}s\")\n        return mw, db\n\n    def prepare_external_db_access(self,network_name:str=\"db\",db_alias:str=\"db\"):\n        \"\"\"\n        make sure the external database container can be reached\n        \"\"\"\n        # ensure network exists\n        nets = {n.name for n in docker.network.list()}\n        if network_name not in nets:\n            docker.network.create(network_name)\n\n        # connect external DB container with alias\n        try:\n            docker.network.connect(\n                network=network_name,\n                container=self.config.db_container_name,\n                alias=db_alias\n            )\n        except Exception as ex:\n            # already connected or harmless -&gt; ignore\n            if not \"already exists\" in str(ex):\n                if self.config.debug:\n                    print(f\"network connect hint: {ex}\", file=sys.stderr)\n\n    def start(self, forceRebuild: bool = False, withInitDB=True):\n        \"\"\"\n        start my containers\n\n        Args:\n            forceRebuild (bool): if True force rebuilding\n            withInitDB (bool): if True intialize my database\n        \"\"\"\n        self.up(forceRebuild=forceRebuild)\n        if self.config.has_external_db:\n            self.prepare_external_db_access()\n        if withInitDB:\n            msg=\"Initializing MediaWiki SQL tables\"\n            if self.config.has_external_db:\n                msg+=\" and permissions\"\n            if self.config.verbose:\n                print(f\"{msg} ...\")\n            if self.config.has_external_db:\n                # Grant permissions first for external DB\n                self.execute(\n                    \"bash\", \"/scripts/setup-mediawiki.sh\",\n                    # do not export root password here - try using ENV variable\n                    #\"--mysql-root-password\", self.config.mySQLRootPassword,\n                    \"--grant\"\n                )\n            dbStatus = self.checkDBConnection()\n            if dbStatus.ok:\n                # run the mediawiki setup including composer based extensions\n                self.setupMediaWiki()\n        if self.config.verbose:\n            print(\n                f\"MediaWiki {self.config.container_base_name} is ready at {self.config.full_url}\"\n            )\n\n    def setupMediaWiki(self):\n        \"\"\"\n        setup MediaWiki via the generated script with explicit args\n        \"\"\"\n        self.execute(\n            \"bash\", \"/scripts/setup-mediawiki.sh\",\n            \"--script-dir\", \"/scripts\",\n            \"--web-dir\", \"/var/www/html\",\n            \"--all\",\n        )\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.__init__","title":"<code>__init__(config)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MwClusterConfig</code> <p>MwClusterConfig,</p> required <code>home</code> <p>the home directory to use</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def __init__(self, config: MwClusterConfig):\n    \"\"\"\n    Constructor\n\n    Args:\n        config: MwClusterConfig,\n        home: the home directory to use\n    \"\"\"\n    self.config = config\n    # branch as need for git clone e.g. https://gerrit.wikimedia.org/g/mediawiki/extensions/MagicNoCache\n    self.branch = f\"REL{self.config.getShortVersion('_')}\"\n    self.composerVersion = 1\n    if self.config.shortVersion &gt;= \"139\":\n        self.composerVersion = 2\n    # jinja and docker prerequisites\n    self.env = self.getJinjaEnv()\n    # docker file location\n    self.docker_path = (\n        f\"{self.config.docker_path}/{self.config.container_base_name}\"\n    )\n    os.makedirs(self.docker_path, exist_ok=True)\n\n    self.getContainers()\n    self.dbConn = None\n    self.wiki_id=self.config.getWikiId()\n    self.database = f\"{self.wiki_id}_wiki\"\n    self.dbUser = f\"{self.wiki_id}_user\"\n    self.wikiUser = None\n    # Hook to allow modifying results\n    # e.g. docker-compose.yaml after generation is finished\n    self.postgen_hook = None\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.check","title":"<code>check()</code>","text":"<p>check me</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode: 0 if ok, 1 if not ok</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def check(self) -&gt; int:\n    \"\"\"\n    check me\n\n    Returns:\n        int: exitCode: 0 if ok, 1 if not ok\n    \"\"\"\n    DockerApplication.checkDockerEnvironment(self.config.debug)\n    exitCode = 0\n    mw, db = self.getContainers()\n    if not mw:\n        print(\"mediawiki container missing\")\n        exitCode = 1\n    if not db:\n        print(\"database container missing\")\n        exitCode = 1\n    if mw and db and mw.check() and db.check():\n        host_port = mw.getHostPort(80)\n        if host_port:\n            Logger.check_and_log_equal(\n                f\"port binding\", host_port, \"expected  port\", str(self.config.port)\n            )\n            version_url = self.get_version_url(host_port)\n            ok = self.checkWiki(version_url)\n            if not ok:\n                exitCode = 1\n        else:\n            self.log(f\"port binding for port 80 missing\", False)\n            exitCode = 1\n        pass\n    return exitCode\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.checkDBConnection","title":"<code>checkDBConnection(timeout=10, initialSleep=4.0, factor=1.5, maxTries=9)</code>","text":"<p>check database connection with retries</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>number of seconds for timeout</p> <code>10</code> <code>initialSleep</code> <code>float</code> <p>number of seconds to initially wait/sleep</p> <code>4.0</code> <code>maxTries</code> <code>int</code> <p>maximum number of retries before giving up between each try a sleep is done that starts</p> <code>9</code> <p>Returns:</p> Name Type Description <code>dbStatus</code> <code>DBStatus</code> <p>the status</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def checkDBConnection(\n    self,\n    timeout: float = 10,\n    initialSleep: float = 4.0,\n    factor=1.5,\n    maxTries: int = 9,\n) -&gt; DBStatus:\n    \"\"\"\n    check database connection with retries\n\n    Args:\n        timeout (float): number of seconds for timeout\n        initialSleep (float): number of seconds to initially wait/sleep\n        maxTries (int): maximum number of retries before giving up between each try a sleep is done that starts\n        with 0.5 secs and multiplies on every retry\n\n    Returns:\n        dbStatus: the status\n    \"\"\"\n    conn_msg = f\"SQL-Connection to {self.database} on {self.config.host} port {self.config.sql_port} with user {self.dbUser}\"\n    dbStatus = DBStatus(attempts=0, ok=False, msg=conn_msg, max_tries=maxTries)\n    if self.config.verbose:\n        print(\n            f\"Trying {dbStatus.msg} with max {maxTries} tries and {timeout}s timeout per try - initial sleep {initialSleep}s\"\n        )\n    time.sleep(initialSleep)\n    sleep = 2.0\n    while not dbStatus.ok and dbStatus.attempts &lt;= maxTries:\n        try:\n            self.doCheckDBConnection(dbStatus, timeout=timeout)\n            if not dbStatus.ok:\n                if self.config.verbose:\n                    print(\n                        f\"Connection attempt #{dbStatus.attempts}/{dbStatus.max_tries} failed will retry in {sleep:4.1f} secs\"\n                    )\n                # wait before trying\n                time.sleep(sleep)\n                sleep = sleep * factor\n        except Exception as ex:\n            dbStatus.ex = ex\n            if self.config.verbose:\n                print(\n                    f\"Connection attempt #{dbStatus.attempts} failed with exception {str(ex)} - will not retry ...\"\n                )\n            if self.config.debug:\n                print(traceback.format_exc())\n            break\n    return dbStatus\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.checkDockerEnvironment","title":"<code>checkDockerEnvironment(debug=False)</code>  <code>staticmethod</code>","text":"<p>check the docker environment</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>if True show debug information</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>an error message or None</p> Source code in <code>mwdocker/docker.py</code> <pre><code>@staticmethod\ndef checkDockerEnvironment(debug: bool = False) -&gt; str:\n    \"\"\"\n    check the docker environment\n\n    Args:\n        debug (bool): if True show debug information\n\n    Returns:\n        str: an error message or None\n    \"\"\"\n    errMsg = None\n    os_path = os.environ[\"PATH\"]\n    paths = [\"/usr/local/bin\"]\n    for path in paths:\n        if os.path.islink(f\"{path}/docker\"):\n            if not path in os_path:\n                os.environ[\"PATH\"] = f\"{os_path}{os.pathsep}{path}\"\n                if debug:\n                    print(\n                        f\"\"\"modified PATH from {os_path} to \\n{os.environ[\"PATH\"]}\"\"\"\n                    )\n    if not docker.compose.is_installed():\n        errMsg = \"\"\"docker compose up needs to be working\"\"\"\n\n    return errMsg\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.checkWiki","title":"<code>checkWiki(version_url)</code>","text":"<p>check this wiki against the content of the given version_url</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def checkWiki(self, version_url: str) -&gt; bool:\n    \"\"\"\n    check this wiki against the content of the given version_url\n    \"\"\"\n    print(f\"Checking {version_url} ...\")\n    ok = True\n    try:\n        html_tables = HtmlTables(version_url)\n        tables = html_tables.get_tables(\"h2\")\n        if self.config.debug:\n            p = pprint.PrettyPrinter(indent=2)\n            p.pprint(tables)\n        ok = ok and Logger.check_and_log(\n            \"Special Version accessible ...\", \"Installed software\" in tables\n        )\n        if ok:\n            software = tables[\"Installed software\"]\n            software_map, _dup = LOD.getLookup(\n                software, \"Product\", withDuplicates=False\n            )\n            mw_version = software_map[\"MediaWiki\"][\"Version\"]\n            ok = ok and Logger.check_and_log_equal(\n                \"Mediawiki Version\", mw_version, \"expected \", self.config.version\n            )\n            db_version_str = software_map[\"MariaDB\"][\"Version\"]\n            db_version = MariaDB.getVersion(db_version_str)\n            ok = ok and Logger.check_and_log(\n                f\"Maria DB Version {db_version} fitting expected {self.config.mariaDBVersion}?\",\n                self.config.mariaDBVersion.startswith(db_version),\n            )\n            pass\n    except Exception as ex:\n        ok = Logger.check_and_log(str(ex), False)\n    return ok\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.close","title":"<code>close()</code>","text":"<p>close the database</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def close(self):\n    \"\"\"\n    close the database\n    \"\"\"\n    self.dbClose()\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.createOrModifyWikiUser","title":"<code>createOrModifyWikiUser(wikiId, force_overwrite=False, lenient=False)</code>","text":"<p>create or modify the WikiUser for this DockerApplication</p> <p>Parameters:</p> Name Type Description Default <code>wikiId</code> <code>str</code> <p>the wikiId to create or modify a wiki user for</p> required <code>force_overwrite</code> <code>bool</code> <p>if True overwrite the wikiuser info</p> <code>False</code> <code>lenient(bool)</code> <p>do not throw Exception if wikiuser exists</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def createOrModifyWikiUser(\n    self, wikiId, force_overwrite: bool = False, lenient: bool = False\n) -&gt; WikiUser:\n    \"\"\"\n    create or modify the WikiUser for this DockerApplication\n\n    Args:\n        wikiId (str): the wikiId to create or modify a wiki user for\n        force_overwrite (bool): if True overwrite the wikiuser info\n        lenient(bool): do not throw Exception if wikiuser exists\n    \"\"\"\n    wikiUsers = WikiUser.getWikiUsers(lenient=True)\n    if wikiId in wikiUsers and not force_overwrite:\n        wikiUser = wikiUsers[wikiId]\n        if self.config.password != wikiUser.getPassword():\n            msg = f\"wikiUser for wiki {wikiId} already exists but with different password\"\n            if lenient:\n                print(msg, file=sys.stderr)\n            else:\n                raise Exception(msg)\n        pass\n    else:\n        wikiUser = self.createWikiUser(wikiId, store=True)\n    return wikiUser\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.createWikiUser","title":"<code>createWikiUser(wikiId=None, store=False)</code>","text":"<p>create my wikiUser and optionally save it</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>bool</code> <p>if True save my user data to the relevant ini File</p> <code>False</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def createWikiUser(self, wikiId: str = None, store: bool = False):\n    \"\"\"\n    create my wikiUser and optionally save it\n\n    Args:\n       store (bool): if True save my user data to the relevant ini File\n    \"\"\"\n    if not wikiId:\n        wikiId = f\"{self.config.container_base_name}\"\n    userDict = {\n        \"wikiId\": f\"{wikiId}\",\n        \"url\": f\"{self.config.base_url}:{self.config.port}\",\n        \"scriptPath\": f\"{self.config.script_path}\",\n        \"user\": f\"{self.config.user}\",\n        \"email\": \"noreply@nouser.com\",\n        \"version\": f\"{self.config.fullVersion}\",\n        \"password\": f\"{self.config.password}\",\n    }\n    wikiUser = WikiUser.ofDict(userDict, encrypted=False)\n    if store:\n        wikiUser.save()\n    return wikiUser\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.dbClose","title":"<code>dbClose()</code>","text":"<p>close the database connection</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def dbClose(self):\n    \"\"\"\n    close the database connection\n    \"\"\"\n    if self.dbConn and self.dbConn.is_connected():\n        self.dbConn.close()\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.dbConnect","title":"<code>dbConnect(timeout=10)</code>","text":"<p>connect to the database and return the connection</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>number of seconds for timeout</p> <code>10</code> <p>Returns:</p> Type Description <p>the connection</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def dbConnect(self, timeout: int = 10):\n    \"\"\"\n    connect to the database and return the connection\n\n    Args:\n        timeout (int): number of seconds for timeout\n\n    Returns:\n        the connection\n    \"\"\"\n    if self.dbConn is None:\n        try:\n            self.dbConn = mysql.connector.connect(\n                host=self.config.host,\n                database=self.database,\n                user=self.dbUser,\n                port=self.config.sql_port,\n                password=self.config.mySQLPassword,\n                connection_timeout=timeout,\n            )\n\n        except Error as e:\n            errMsg = str(e)\n            print(\n                f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} failed error: {errMsg}\"\n            )\n            if \"Access denied\" in errMsg:\n                raise e\n    return self.dbConn\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.doCheckDBConnection","title":"<code>doCheckDBConnection(dbStatus, timeout=10)</code>","text":"<p>check the database connection of this application</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>how many seconds to wait</p> <code>10</code> <p>Returns:</p> Type Description <p>DBStatus</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def doCheckDBConnection(self, dbStatus: DBStatus, timeout: int = 10):\n    \"\"\"\n    check the database connection of this application\n\n    Args:\n        timeout (int): how many seconds to wait\n\n    Returns:\n        DBStatus\n    \"\"\"\n    dbStatus.attempts += 1\n    self.dbConnect(timeout=timeout)\n    if self.dbConn and self.dbConn.is_connected():\n        rows = self.sqlQuery(\"select database();\")\n        dbStatus.ok = True\n        if self.config.verbose:\n            print(f\"{dbStatus.msg} established database returns: {rows[0]}\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.down","title":"<code>down(forceRebuild=False)</code>","text":"<p>run docker compose down</p> <p>see https://docs.docker.com/engine/reference/commandline/compose_down/ and https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/compose/#down</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def down(self, forceRebuild: bool = False):\n    \"\"\"\n    run docker compose down\n\n    see https://docs.docker.com/engine/reference/commandline/compose_down/\n    and https://gabrieldemarmiesse.github.io/python-on-whales/sub-commands/compose/#down\n\n    \"\"\"\n    DockerApplication.checkDockerEnvironment(self.config.debug)\n    # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n    if self.config.verbose:\n        print(\n            f\"running docker compose down for {self.config.container_base_name} {self.config.version} docker application ...\"\n        )\n    # remember current directory\n    cwd = os.getcwd()\n    os.chdir(self.docker_path)\n    try:\n        docker.compose.down(volumes=forceRebuild)\n    except DockerException as dex:\n        print(f\"warning: docker compose down failed in {self.docker_path}:{str(dex)}\")\n        pass\n    # switch back to previous current directory\n    os.chdir(cwd)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.execute","title":"<code>execute(*commands)</code>","text":"<p>Execute the given variable list of command strings inside the MediaWiki container.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>str</code> <p>str - command parts to be executed</p> <code>()</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def execute(self, *commands: str):\n    \"\"\"\n    Execute the given variable list of command strings inside the MediaWiki container.\n\n    Args:\n        commands: str - command parts to be executed\n    \"\"\"\n    if not self.mwContainer:\n        mwContainerNameDash = self.getContainerName(\"mw\", \"-\")\n        mwContainerNameUnderscore = self.getContainerName(\"mw\", \"_\")\n        raise Exception(\n          f\"no mediawiki Container {mwContainerNameDash} or {mwContainerNameUnderscore} for {self.name} \"\n          f\"activated by docker compose\\n- you might want to check the separator character used \"\n          f\"for container names for your platform {platform.system()}\"\n        )\n    self.mwContainer.execute(*commands,verbose=self.config.verbose)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.genComposerRequire","title":"<code>genComposerRequire(composerFilePath, overwrite=False)</code>","text":"<p>gen the composer.local.json require file</p> <p>Parameters:</p> Name Type Description Default <code>composerFilePath</code> <code>str</code> <p>the name of the file to generate</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def genComposerRequire(self, composerFilePath, overwrite: bool = False):\n    \"\"\"\n    gen the composer.local.json require file\n\n    Args:\n        composerFilePath (str): the name of the file to generate\n    \"\"\"\n    requireJson = self.getComposerRequire()\n    self.optionalWrite(composerFilePath, requireJson, overwrite)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.generate","title":"<code>generate(templateName, targetPath, overwrite=False, **kwArgs)</code>","text":"<p>generate file at targetPath using the given templateName</p> <p>Parameters:</p> Name Type Description Default <code>templateName</code> <code>str</code> <p>the Jinja2 template to use</p> required <code>targetPath</code> <code>str</code> <p>the path to the target file</p> required <code>overwrite</code> <code>bool</code> <p>if True overwrite existing files</p> <code>False</code> <code>kwArgs()</code> <p>generic keyword arguments to pass on to template rendering</p> required Source code in <code>mwdocker/docker.py</code> <pre><code>def generate(\n    self, templateName: str, targetPath: str, overwrite: bool = False, **kwArgs\n):\n    \"\"\"\n    generate file at targetPath using the given templateName\n\n    Args:\n        templateName (str): the Jinja2 template to use\n        targetPath (str): the path to the target file\n        overwrite (bool): if True overwrite existing files\n        kwArgs(): generic keyword arguments to pass on to template rendering\n    \"\"\"\n    try:\n        template = self.env.get_template(templateName)\n        timestamp = datetime.datetime.now().isoformat()\n        content = template.render(\n            mwVersion=self.config.version,\n            mariaDBVersion=self.config.mariaDBVersion,\n            port=self.config.port,\n            sql_port=self.config.sql_port,\n            smw_version=self.config.smw_version,\n            timestamp=timestamp,\n            pmwdVersion=Version.version,\n            config=self.config,\n            **kwArgs,\n        )\n        self.optionalWrite(targetPath, content, overwrite)\n\n    except TemplateNotFound:\n        print(f\"no template {templateName} for {self.config.version}\")\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.generateAll","title":"<code>generateAll(overwrite=False)</code>","text":"<p>generate all files needed for the docker handling</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>if True overwrite the existing files</p> <code>False</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def generateAll(self, overwrite: bool = False):\n    \"\"\"\n    generate all files needed for the docker handling\n\n    Args:\n        overwrite (bool): if True overwrite the existing files\n    \"\"\"\n    # make sure we have the wiki_id ready\n    wiki_id=self.config.getWikiId()\n    # we have to configure whether\n    # bind mounts or volumes are to be used\n    if self.config.bind_mount:\n        volume_type = \"bind\"\n        mysql_data = f\"/var/lib/mediawiki/mysql/{self.config.shortVersion}\"\n        wiki_sites = f\"/var/www/mediawiki/sites\"\n    else:\n        volume_type = \"volume\"\n        mysql_data = \"mysql-data\"\n        wiki_sites = \"wiki-sites\"\n    # first generate Dockerfile\n    # the goal is to get an empty MediaWiki (no LocalSettings/extensions)\n    # with composer ready\n    self.generate(\n        \"mwDockerfile\",\n        f\"{self.docker_path}/Dockerfile\",\n        composerVersion=self.composerVersion,\n        volume_type=volume_type,\n        overwrite=overwrite,\n    )\n    # the master setup script\n    # this used to be part of Dockerfile but\n    # needs to be scripted when we use bind mounts due\n    # to docker's poor design of permission and mount handling\n    self.generate(\n        f\"setup-mediawiki.sh\",\n        f\"{self.docker_path}/setup-mediawiki.sh\",\n        script_dir=\"/scripts\",\n        web_dir=\"/var/www/html\",\n        overwrite=overwrite,\n    )\n    # the Docker compose\n    # at this stage we will have two containers\n    # one for the database and one for the MediaWiki\n    # the db container may be optionally an existing database container\n    template_name = \"mwComposeExternalDB.yml\" if self.config.has_external_db else \"mwCompose.yml\"\n    self.generate(\n        template_name,\n        f\"{self.docker_path}/docker-compose.yml\",\n        # might be None for ExternalDB case\n        mySQLRootPassword=self.config.mySQLRootPassword,\n        mySQLPassword=self.config.mySQLPassword,\n        container_base_name=self.config.container_base_name,\n        db_container_name=self.config.db_container_name,\n        wiki_id=wiki_id,\n        volume_type=volume_type,\n        mysql_data=mysql_data,\n        wiki_sites=wiki_sites,\n        scripts_dir=self.docker_path,\n        uid=self.config.uid,\n        gid=self.config.gid,\n        overwrite=overwrite,\n    )\n    # now generate the parts we will use later to\n    # create the fully configured wiki\n    # first - LocalSettings with references to all extensions\n    self.generate(\n        f\"mwLocalSettings{self.config.shortVersion}.php\",\n        f\"{self.docker_path}/LocalSettings.php\",\n        wiki_id=wiki_id,\n        mySQLPassword=self.config.mySQLPassword,\n        hostname=self.config.host,\n        extensions=self.config.extensionMap.values(),\n        mwShortVersion=self.config.shortVersion,\n        logo=self.config.logo,\n        overwrite=overwrite,\n    )\n    # the SQL file for initial content\n    self.generate(\n        f\"mwWiki{self.config.shortVersion}.sql\",\n        f\"{self.docker_path}/wiki.sql\",\n        overwrite=overwrite,\n    )\n    # a WikiUser for automated access via\n    # py-3rdparty mediawiki\n    if self.config.random_password:\n        self.config.password = self.config.create_random_password(\n            length=self.config.password_length\n        )\n        if self.config.wikiId:\n            self.createOrModifyWikiUser(\n                self.config.wikiId,\n                force_overwrite=self.config.force_user,\n                lenient=self.config.lenient,\n            )\n    self.generate(\n        f\"addSysopUser.sh\",\n        f\"{self.docker_path}/addSysopUser.sh\",\n        user=self.config.user,\n        password=self.config.password,\n        overwrite=overwrite,\n    )\n    self.generate(\n        f\"installExtensions.sh\",\n        f\"{self.docker_path}/installExtensions.sh\",\n        extensions=self.config.extensionMap.values(),\n        branch=self.branch,\n        overwrite=overwrite,\n    )\n    self.genComposerRequire(\n        f\"{self.docker_path}/composer.local.json\", overwrite=overwrite\n    )\n    for file_name in [\n        \"phpinfo.php\",\n        \"disable_sudo.sh\",\n        \"install_djvu.sh\",\n        \"plantuml.sh\",\n        \"upload.ini\",\n    ]:\n        self.generate(\n            f\"{file_name}\", f\"{self.docker_path}/{file_name}\", overwrite=overwrite\n        )\n\n    # chmod generated scripts that need to be bash callable\n    # to be executable on container operating system (linux)\n    # when bind mounted or being copied\n    for executable in [\n        \"disable_sudo.sh\",\n        \"install_djvu.sh\",\n        \"plantuml.sh\",\n        \"addSysopUser.sh\",\n        \"installExtensions.sh\",\n        \"setup-mediawiki.sh\",\n    ]:\n        path = os.path.join(self.docker_path, executable)\n        if os.path.exists(path):\n            st = os.stat(path)\n            os.chmod(path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)\n\n    if self.postgen_hook:\n        self.postgen_hook(self)\n\n    # remember the configuration we used for generating\n    # avoid endless loop - forceRebuilds - we have rebuild already\n    forceRebuild = self.config.forceRebuild\n    self.config.forceRebuild = False\n    self.config.save()\n    self.config.forceRebuild = forceRebuild\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getComposerRequire","title":"<code>getComposerRequire()</code>","text":"<p>get the json string for the composer require e.g. composer.local.json</p> Source code in <code>mwdocker/docker.py</code> <pre><code>    def getComposerRequire(self):\n        \"\"\"\n        get the json string for the composer require e.g. composer.local.json\n        \"\"\"\n        requires = []\n        for ext in self.config.extensionMap.values():\n            # get the composer statement\n            if ext.composer:\n                requires.append(ext.composer)\n        indent = \"     \"\n        delim = \"\" if len(requires) == 0 else \",\\n\"\n        requireList = \"\"\n        if self.config.smw_version:\n            requireList += f'{indent}\"mediawiki/semantic-media-wiki\": \"~{self.config.smw_version}\"{delim}'\n        for i, require in enumerate(requires):\n            delim = \"\" if i &gt;= len(requires) - 1 else \",\\n\"\n            requireList += f\"{indent}{require}{delim}\"\n        requireJson = f\"\"\"{{\n  \"require\": {{\n{requireList}\n  }}\n}}\"\"\"\n        return requireJson\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getContainerName","title":"<code>getContainerName(kind, separator)</code>","text":"<p>get my container Name</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getContainerName(self, kind: str, separator: str):\n    \"\"\"\n    get my container Name\n    \"\"\"\n    containerName = f\"{self.config.container_base_name}{separator}{kind}\"\n    return containerName\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getContainers","title":"<code>getContainers()</code>","text":"<p>get my containers</p> <p>Returns:</p> Type Description <p>Tuple(</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getContainers(self):\n    \"\"\"\n    get my containers\n\n    Returns:\n        Tuple(\n    \"\"\"\n    self.dbContainer = None\n    self.mwContainer = None\n    containerMap = DockerMap.getContainerMap()\n    for separator in [\"-\", \"_\"]:\n        dbContainerName = self.getContainerName(\"db\", separator)\n        mwContainerName = self.getContainerName(\"mw\", separator)\n        if dbContainerName in containerMap:\n            self.dbContainer = DockerContainer(\n                dbContainerName, \"database\", containerMap[dbContainerName]\n            )\n        if mwContainerName in containerMap:\n            self.mwContainer = DockerContainer(\n                mwContainerName, \"webserver\", containerMap[mwContainerName]\n            )\n    return self.mwContainer, self.dbContainer\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.getJinjaEnv","title":"<code>getJinjaEnv()</code>","text":"<p>get a Jinja2 environment</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getJinjaEnv(self):\n    \"\"\"\n    get a Jinja2 environment\n    \"\"\"\n    scriptdir = os.path.dirname(os.path.realpath(__file__))\n    resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n    template_dir = os.path.realpath(f\"{resourcePath}/templates\")\n    # print(f\"jinja template directory is {template_dir}\")\n    env = Environment(loader=FileSystemLoader(template_dir))\n    return env\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.get_version_url","title":"<code>get_version_url(host_port)</code>","text":"<p>get the Special:Version url</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def get_version_url(self, host_port: str) -&gt; str:\n    \"\"\"\n    get the Special:Version url\n    \"\"\"\n    url = self.config.full_url\n    # fix url to local port\n    # @TODO isn't this superfluous / has no effect ...?\n    url = url.replace(str(self.config.port), host_port)\n    version_url = f\"{url}/index.php?title=Special:Version\"\n    return version_url\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.optionalWrite","title":"<code>optionalWrite(targetPath, content, overwrite=False)</code>","text":"<p>optionally Write the modified content to the given targetPath</p> <p>Parameters:</p> Name Type Description Default <code>targetPath</code> <code>str</code> <p>the path to write the content to</p> required <code>content</code> <code>str</code> <p>the content to write</p> required <code>overwrite</code> <code>bool</code> <p>if True overwrite the existing content</p> <code>False</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def optionalWrite(self, targetPath: str, content: str, overwrite: bool = False):\n    \"\"\"\n    optionally Write the modified content to the given targetPath\n\n    Args:\n        targetPath (str): the path to write the content to\n        content (str): the content to write\n        overwrite (bool): if True overwrite the existing content\n    \"\"\"\n    if not overwrite and os.path.isfile(targetPath):\n        if self.config.verbose:\n            print(f\"{targetPath} already exists!\")\n        return\n    with open(targetPath, \"w\", newline=\"\") as targetFile:\n        targetFile.write(content)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.prepare_external_db_access","title":"<code>prepare_external_db_access(network_name='db', db_alias='db')</code>","text":"<p>make sure the external database container can be reached</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def prepare_external_db_access(self,network_name:str=\"db\",db_alias:str=\"db\"):\n    \"\"\"\n    make sure the external database container can be reached\n    \"\"\"\n    # ensure network exists\n    nets = {n.name for n in docker.network.list()}\n    if network_name not in nets:\n        docker.network.create(network_name)\n\n    # connect external DB container with alias\n    try:\n        docker.network.connect(\n            network=network_name,\n            container=self.config.db_container_name,\n            alias=db_alias\n        )\n    except Exception as ex:\n        # already connected or harmless -&gt; ignore\n        if not \"already exists\" in str(ex):\n            if self.config.debug:\n                print(f\"network connect hint: {ex}\", file=sys.stderr)\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.setupMediaWiki","title":"<code>setupMediaWiki()</code>","text":"<p>setup MediaWiki via the generated script with explicit args</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def setupMediaWiki(self):\n    \"\"\"\n    setup MediaWiki via the generated script with explicit args\n    \"\"\"\n    self.execute(\n        \"bash\", \"/scripts/setup-mediawiki.sh\",\n        \"--script-dir\", \"/scripts\",\n        \"--web-dir\", \"/var/www/html\",\n        \"--all\",\n    )\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.sqlQuery","title":"<code>sqlQuery(query)</code>","text":"<p>run the given SQL query</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def sqlQuery(self, query):\n    \"\"\"\n    run the given SQL query\n    \"\"\"\n    if self.dbConn and self.dbConn.is_connected():\n        cursor = self.dbConn.cursor()\n        cursor.execute(query)\n        rows = cursor.fetchall()\n        cursor.close()\n        return rows\n    else:\n        if self.config.verbose:\n            print(\n                f\"Connection to {self.database} on {self.config.host} with user {self.dbUser} not established\"\n            )\n        return None\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.start","title":"<code>start(forceRebuild=False, withInitDB=True)</code>","text":"<p>start my containers</p> <p>Parameters:</p> Name Type Description Default <code>forceRebuild</code> <code>bool</code> <p>if True force rebuilding</p> <code>False</code> <code>withInitDB</code> <code>bool</code> <p>if True intialize my database</p> <code>True</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def start(self, forceRebuild: bool = False, withInitDB=True):\n    \"\"\"\n    start my containers\n\n    Args:\n        forceRebuild (bool): if True force rebuilding\n        withInitDB (bool): if True intialize my database\n    \"\"\"\n    self.up(forceRebuild=forceRebuild)\n    if self.config.has_external_db:\n        self.prepare_external_db_access()\n    if withInitDB:\n        msg=\"Initializing MediaWiki SQL tables\"\n        if self.config.has_external_db:\n            msg+=\" and permissions\"\n        if self.config.verbose:\n            print(f\"{msg} ...\")\n        if self.config.has_external_db:\n            # Grant permissions first for external DB\n            self.execute(\n                \"bash\", \"/scripts/setup-mediawiki.sh\",\n                # do not export root password here - try using ENV variable\n                #\"--mysql-root-password\", self.config.mySQLRootPassword,\n                \"--grant\"\n            )\n        dbStatus = self.checkDBConnection()\n        if dbStatus.ok:\n            # run the mediawiki setup including composer based extensions\n            self.setupMediaWiki()\n    if self.config.verbose:\n        print(\n            f\"MediaWiki {self.config.container_base_name} is ready at {self.config.full_url}\"\n        )\n</code></pre>"},{"location":"#mwdocker.docker.DockerApplication.up","title":"<code>up(forceRebuild=False)</code>","text":"<p>start this docker application</p> <p>Parameters:</p> Name Type Description Default <code>forceRebuild</code> <code>bool</code> <p>if true stop and remove the existing containers</p> <code>False</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def up(self, forceRebuild: bool = False):\n    \"\"\"\n    start this docker application\n\n    Args:\n        forceRebuild (bool): if true stop and remove the existing containers\n    \"\"\"\n    DockerApplication.checkDockerEnvironment(self.config.debug)\n    if self.config.verbose:\n        print(\n            f\"starting {self.config.container_base_name} {self.config.version} docker application ...\"\n        )\n    if forceRebuild:\n        for docker_container in [self.dbContainer, self.mwContainer]:\n            if docker_container is not None:\n                container = docker_container.container\n                try:\n                    container_name = container.name\n                    if self.config.verbose:\n                        print(f\"stopping and removing container {container_name}\")\n                except Exception as container_ex:\n                    container = None\n                if container:\n                    try:\n                        container.stop()\n                    except Exception as stop_ex:\n                        if self.config.verbose:\n                            print(f\"stop failed with {str(stop_ex)}\")\n                        pass\n                    try:\n                        container.remove()\n                    except Exception as remove_ex:\n                        if self.config.verbose:\n                            print(f\"removed failed with {str(remove_ex)}\")\n                        pass\n                pass\n\n    # remember current directory\n    cwd = os.getcwd()\n\n    # change directory so that docker CLI will find the relevant dockerfile and docker-compose.yml\n    os.chdir(self.docker_path)\n    # project_config = docker.compose.config()\n    if forceRebuild:\n        docker.compose.build()\n    # run docker compose up\n    # this might take a while e.g. downloading\n    # run docker compose up\n    try:\n        docker.compose.up(detach=True, force_recreate=forceRebuild)\n    except Exception as de:\n        print(f\"docker compose up failed in {self.docker_path}\")\n        raise de\n        pass\n    # switch back to previous current directory\n    os.chdir(cwd)\n\n    # check the startup of both containers\n    mw, db = self.getContainers()\n    for dc in [mw, db]:\n        if dc:\n            start_secs = dc.wait_for_state(running=True)\n            if self.config.verbose:\n                print(f\"{dc.name} \ud83d\udfe2 started in {start_secs:.2f}s\")\n    return mw, db\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer","title":"<code>DockerContainer</code>","text":"<p>helper class for docker container info</p> Source code in <code>mwdocker/docker.py</code> <pre><code>class DockerContainer:\n    \"\"\"\n    helper class for docker container info\n    \"\"\"\n\n    def __init__(self, name, kind, container):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.name = name\n        self.kind = kind\n        self.container = container\n\n    def check(self):\n        \"\"\"\n        check the given docker container\n\n        print check message and Return if container is running\n\n        Args:\n            dc: the docker container\n\n        Returns:\n            bool: True if the container is not None\n        \"\"\"\n        ok = self.container.state.running\n        msg = f\"mediawiki {self.kind} container {self.name}\"\n        return Logger.check_and_log(msg, ok)\n\n    def detect_crash(self) -&gt; str:\n        \"\"\"\n        check that we are still running and get crash details if not\n\n        Returns:\n            str: None if running, log if crashed\n        \"\"\"\n        logs = None\n        try:\n            if not self.container.state.running:\n                logs = docker.container.logs(self.name)\n        except Exception as ex:\n            logs = str(ex)\n        return logs\n\n    def wait_for_state(\n        self, running: bool, interval: float = 0.2, timeout: float = 60.0\n    ) -&gt; float:\n        \"\"\"\n        Wait until the container reaches the desired running state\n\n        Args:\n            running: desired running state (True = wait until started, False = wait until stopped)\n            interval: polling interval in seconds\n            timeout: max time to wait\n\n        Returns:\n            float: Time in seconds it took to reach the desired state\n\n        Raises:\n            TimeoutError: if the desired state is not reached within timeout\n        \"\"\"\n        start_time = time.time()\n        deadline = start_time + timeout\n        while time.time() &lt; deadline:\n            if self.container.state.running == running:\n                return time.time() - start_time\n            time.sleep(interval)\n        state = \"running\" if running else \"stopped\"\n        raise TimeoutError(\n            f\"Container '{self.name}' did not reach state '{state}' within {timeout} seconds\"\n        )\n\n    def getHostPort(self, local_port: int = 80) -&gt; int:\n        \"\"\"\n        get the host port for the given local port\n\n        Args:\n            local_port (int): the local port to get the mapping for\n\n        Returns:\n            int: the  host port or None\n        \"\"\"\n        host_port = None\n        pb_dict = self.container.host_config.port_bindings\n        p_local = f\"{local_port}/tcp\"\n        if p_local in pb_dict:\n            pb = pb_dict[p_local][0]\n            host_port = pb.host_port\n        return host_port\n\n    def execute(self, *commands: str,verbose:bool=False):\n        \"\"\"\n        Execute the given variable list of command strings inside the MediaWiki container.\n\n        Args:\n            commands: str - command parts to be executed\n        \"\"\"\n        command_list = list(commands)\n\n\n        if verbose:\n            command_line = \" \".join(command_list)\n            print(f\"Executing docker command: {command_line}\")\n\n        try:\n            # see https://gabrieldemarmiesse.github.io/python-on-whales/user_guide/docker_run/#stream-the-output\n            for stream_type,stream_content in docker.execute(\n                container=self.container,\n                command=command_list,\n                stream=True):\n                    decoded_line = stream_content.decode(\"utf-8\", errors=\"replace\")\n                    target_stream = sys.stderr if stream_type == \"stderr\" else sys.stdout\n                    print(decoded_line, end=\"\", file=target_stream)\n\n        except Exception as ex:\n            logs = self.detect_crash()\n            if logs is not None:\n                print(f\"{self.name} crashed with log: {logs}\")\n                raise Exception(\n                    f\"Container {self.name} crashed during execute: {ex}\"\n                )\n            else:\n                raise ex\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.__init__","title":"<code>__init__(name, kind, container)</code>","text":"<p>constructor</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def __init__(self, name, kind, container):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.name = name\n    self.kind = kind\n    self.container = container\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.check","title":"<code>check()</code>","text":"<p>check the given docker container</p> <p>print check message and Return if container is running</p> <p>Parameters:</p> Name Type Description Default <code>dc</code> <p>the docker container</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the container is not None</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def check(self):\n    \"\"\"\n    check the given docker container\n\n    print check message and Return if container is running\n\n    Args:\n        dc: the docker container\n\n    Returns:\n        bool: True if the container is not None\n    \"\"\"\n    ok = self.container.state.running\n    msg = f\"mediawiki {self.kind} container {self.name}\"\n    return Logger.check_and_log(msg, ok)\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.detect_crash","title":"<code>detect_crash()</code>","text":"<p>check that we are still running and get crash details if not</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>None if running, log if crashed</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def detect_crash(self) -&gt; str:\n    \"\"\"\n    check that we are still running and get crash details if not\n\n    Returns:\n        str: None if running, log if crashed\n    \"\"\"\n    logs = None\n    try:\n        if not self.container.state.running:\n            logs = docker.container.logs(self.name)\n    except Exception as ex:\n        logs = str(ex)\n    return logs\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.execute","title":"<code>execute(*commands, verbose=False)</code>","text":"<p>Execute the given variable list of command strings inside the MediaWiki container.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>str</code> <p>str - command parts to be executed</p> <code>()</code> Source code in <code>mwdocker/docker.py</code> <pre><code>def execute(self, *commands: str,verbose:bool=False):\n    \"\"\"\n    Execute the given variable list of command strings inside the MediaWiki container.\n\n    Args:\n        commands: str - command parts to be executed\n    \"\"\"\n    command_list = list(commands)\n\n\n    if verbose:\n        command_line = \" \".join(command_list)\n        print(f\"Executing docker command: {command_line}\")\n\n    try:\n        # see https://gabrieldemarmiesse.github.io/python-on-whales/user_guide/docker_run/#stream-the-output\n        for stream_type,stream_content in docker.execute(\n            container=self.container,\n            command=command_list,\n            stream=True):\n                decoded_line = stream_content.decode(\"utf-8\", errors=\"replace\")\n                target_stream = sys.stderr if stream_type == \"stderr\" else sys.stdout\n                print(decoded_line, end=\"\", file=target_stream)\n\n    except Exception as ex:\n        logs = self.detect_crash()\n        if logs is not None:\n            print(f\"{self.name} crashed with log: {logs}\")\n            raise Exception(\n                f\"Container {self.name} crashed during execute: {ex}\"\n            )\n        else:\n            raise ex\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.getHostPort","title":"<code>getHostPort(local_port=80)</code>","text":"<p>get the host port for the given local port</p> <p>Parameters:</p> Name Type Description Default <code>local_port</code> <code>int</code> <p>the local port to get the mapping for</p> <code>80</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the  host port or None</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def getHostPort(self, local_port: int = 80) -&gt; int:\n    \"\"\"\n    get the host port for the given local port\n\n    Args:\n        local_port (int): the local port to get the mapping for\n\n    Returns:\n        int: the  host port or None\n    \"\"\"\n    host_port = None\n    pb_dict = self.container.host_config.port_bindings\n    p_local = f\"{local_port}/tcp\"\n    if p_local in pb_dict:\n        pb = pb_dict[p_local][0]\n        host_port = pb.host_port\n    return host_port\n</code></pre>"},{"location":"#mwdocker.docker.DockerContainer.wait_for_state","title":"<code>wait_for_state(running, interval=0.2, timeout=60.0)</code>","text":"<p>Wait until the container reaches the desired running state</p> <p>Parameters:</p> Name Type Description Default <code>running</code> <code>bool</code> <p>desired running state (True = wait until started, False = wait until stopped)</p> required <code>interval</code> <code>float</code> <p>polling interval in seconds</p> <code>0.2</code> <code>timeout</code> <code>float</code> <p>max time to wait</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time in seconds it took to reach the desired state</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>if the desired state is not reached within timeout</p> Source code in <code>mwdocker/docker.py</code> <pre><code>def wait_for_state(\n    self, running: bool, interval: float = 0.2, timeout: float = 60.0\n) -&gt; float:\n    \"\"\"\n    Wait until the container reaches the desired running state\n\n    Args:\n        running: desired running state (True = wait until started, False = wait until stopped)\n        interval: polling interval in seconds\n        timeout: max time to wait\n\n    Returns:\n        float: Time in seconds it took to reach the desired state\n\n    Raises:\n        TimeoutError: if the desired state is not reached within timeout\n    \"\"\"\n    start_time = time.time()\n    deadline = start_time + timeout\n    while time.time() &lt; deadline:\n        if self.container.state.running == running:\n            return time.time() - start_time\n        time.sleep(interval)\n    state = \"running\" if running else \"stopped\"\n    raise TimeoutError(\n        f\"Container '{self.name}' did not reach state '{state}' within {timeout} seconds\"\n    )\n</code></pre>"},{"location":"#mwdocker.docker_map","title":"<code>docker_map</code>","text":"<p>Created on 2025-08-21</p> <p>@author: wf</p>"},{"location":"#mwdocker.docker_map.DockerMap","title":"<code>DockerMap</code>","text":"<p>helper class to convert lists of docker elements to maps for improved lookup functionality</p> Source code in <code>mwdocker/docker_map.py</code> <pre><code>class DockerMap:\n    \"\"\"\n    helper class to convert lists of docker elements to maps for improved\n    lookup functionality\n    \"\"\"\n\n    _container_map = None\n\n    @classmethod\n    def getContainer(cls,container_name:str):\n        containerMap = DockerMap.getContainerMap()\n        if not container_name in containerMap:\n            raise ValueError(f\"container {container_name} is not a valid docker container\")\n        container=containerMap.get(container_name)\n        return container\n\n    @classmethod\n    def getEnv(cls,container_name:str)-&gt;Dict[str,str]:\n        container=cls.getContainer(container_name)\n        env_dict = {}\n        env_list=container.config.env\n        for key_value in env_list:\n            if '=' in key_value:\n                key, value = key_value.split('=', 1)\n                env_dict[key] = value\n        return env_dict\n\n    @staticmethod\n    def getContainerMap(force_refresh: bool = True)-&gt;Dict[str,Container]:\n        \"\"\"\n        get a cached map/dict of containers by container name\n\n        Args:\n            force_refresh: if True, refresh from docker instead of using cache\n        \"\"\"\n        if DockerMap._container_map is None or force_refresh:\n            DockerMap._container_map = {}\n            for container in docker.container.list():\n                DockerMap._container_map[container.name] = container\n        return DockerMap._container_map\n</code></pre>"},{"location":"#mwdocker.docker_map.DockerMap.getContainerMap","title":"<code>getContainerMap(force_refresh=True)</code>  <code>staticmethod</code>","text":"<p>get a cached map/dict of containers by container name</p> <p>Parameters:</p> Name Type Description Default <code>force_refresh</code> <code>bool</code> <p>if True, refresh from docker instead of using cache</p> <code>True</code> Source code in <code>mwdocker/docker_map.py</code> <pre><code>@staticmethod\ndef getContainerMap(force_refresh: bool = True)-&gt;Dict[str,Container]:\n    \"\"\"\n    get a cached map/dict of containers by container name\n\n    Args:\n        force_refresh: if True, refresh from docker instead of using cache\n    \"\"\"\n    if DockerMap._container_map is None or force_refresh:\n        DockerMap._container_map = {}\n        for container in docker.container.list():\n            DockerMap._container_map[container.name] = container\n    return DockerMap._container_map\n</code></pre>"},{"location":"#mwdocker.html_table","title":"<code>html_table</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#mwdocker.html_table.HtmlTables","title":"<code>HtmlTables</code>","text":"<p>               Bases: <code>WebScrape</code></p> <p>HtmlTables extractor</p> Source code in <code>mwdocker/html_table.py</code> <pre><code>class HtmlTables(WebScrape):\n    \"\"\"\n    HtmlTables extractor\n    \"\"\"\n\n    def __init__(self, url: str, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n\n        url(str): the url to read the tables from\n        debug(bool): if True switch on debugging\n        showHtml(bool): if True show the HTML retrieved\n        \"\"\"\n        super().__init__(debug, showHtml)\n        self.soup = super().getSoup(url, showHtml)\n\n    def get_tables(self, header_tag: str = None) -&gt; dict:\n        \"\"\"\n        get all tables from my soup as a list of list of dicts\n\n        Args:\n            header_tag(str): if set search the table name from the given header tag\n\n        Return:\n            dict: the list of list of dicts for all tables\n\n        \"\"\"\n        tables = {}\n        for i, table in enumerate(self.soup.find_all(\"table\")):\n            fields = []\n            table_data = []\n            category = None\n            for tr in table.find_all(\"tr\", recursive=True):\n                for th in tr.find_all(\"th\", recursive=True):\n                    if \"colspan\" in th.attrs:\n                        category = th.text\n                    else:\n                        fields.append(th.text)\n            for tr in table.find_all(\"tr\", recursive=True):\n                record = {}\n                for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                    record[fields[i]] = td.text\n                if record:\n                    if category:\n                        record[\"category\"] = category\n                    table_data.append(record)\n            if header_tag is not None:\n                header = table.find_previous_sibling(header_tag)\n                table_name = header.text\n            else:\n                table_name = f\"table{i}\"\n            tables[table_name] = table_data\n        return tables\n</code></pre>"},{"location":"#mwdocker.html_table.HtmlTables.__init__","title":"<code>__init__(url, debug=False, showHtml=False)</code>","text":"<p>Constructor</p> <p>url(str): the url to read the tables from debug(bool): if True switch on debugging showHtml(bool): if True show the HTML retrieved</p> Source code in <code>mwdocker/html_table.py</code> <pre><code>def __init__(self, url: str, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n\n    url(str): the url to read the tables from\n    debug(bool): if True switch on debugging\n    showHtml(bool): if True show the HTML retrieved\n    \"\"\"\n    super().__init__(debug, showHtml)\n    self.soup = super().getSoup(url, showHtml)\n</code></pre>"},{"location":"#mwdocker.html_table.HtmlTables.get_tables","title":"<code>get_tables(header_tag=None)</code>","text":"<p>get all tables from my soup as a list of list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>header_tag(str)</code> <p>if set search the table name from the given header tag</p> required Return <p>dict: the list of list of dicts for all tables</p> Source code in <code>mwdocker/html_table.py</code> <pre><code>def get_tables(self, header_tag: str = None) -&gt; dict:\n    \"\"\"\n    get all tables from my soup as a list of list of dicts\n\n    Args:\n        header_tag(str): if set search the table name from the given header tag\n\n    Return:\n        dict: the list of list of dicts for all tables\n\n    \"\"\"\n    tables = {}\n    for i, table in enumerate(self.soup.find_all(\"table\")):\n        fields = []\n        table_data = []\n        category = None\n        for tr in table.find_all(\"tr\", recursive=True):\n            for th in tr.find_all(\"th\", recursive=True):\n                if \"colspan\" in th.attrs:\n                    category = th.text\n                else:\n                    fields.append(th.text)\n        for tr in table.find_all(\"tr\", recursive=True):\n            record = {}\n            for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                record[fields[i]] = td.text\n            if record:\n                if category:\n                    record[\"category\"] = category\n                table_data.append(record)\n        if header_tag is not None:\n            header = table.find_previous_sibling(header_tag)\n            table_name = header.text\n        else:\n            table_name = f\"table{i}\"\n        tables[table_name] = table_data\n    return tables\n</code></pre>"},{"location":"#mwdocker.logger","title":"<code>logger</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#mwdocker.logger.Logger","title":"<code>Logger</code>","text":"<p>               Bases: <code>object</code></p> <p>simple logger</p> Source code in <code>mwdocker/logger.py</code> <pre><code>class Logger(object):\n    \"\"\"\n    simple logger\n    \"\"\"\n\n    @classmethod\n    def check_and_log(cls, msg: str, ok: bool) -&gt; bool:\n        \"\"\"\n        log the given message with the given ok flag\n\n        Args:\n            msg(str): the message to log/print\n            ok(bool): if True show \u2705 marker else \u274c\n\n        Return:\n            bool: the ok parameter for fluid syntax\n        \"\"\"\n        marker = \"\u2705\" if ok else \"\u274c\"\n        print(f\"{msg}:{marker}\")\n        return ok\n\n    @classmethod\n    def check_and_log_equal(self, nameA, valueA, nameB, valueB):\n        msg = f\"{nameA} {valueA}= {nameB} {valueB}?\"\n        return self.check_and_log(msg, valueA == valueB)\n</code></pre>"},{"location":"#mwdocker.logger.Logger.check_and_log","title":"<code>check_and_log(msg, ok)</code>  <code>classmethod</code>","text":"<p>log the given message with the given ok flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to log/print</p> required <code>ok(bool)</code> <p>if True show \u2705 marker else \u274c</p> required Return <p>bool: the ok parameter for fluid syntax</p> Source code in <code>mwdocker/logger.py</code> <pre><code>@classmethod\ndef check_and_log(cls, msg: str, ok: bool) -&gt; bool:\n    \"\"\"\n    log the given message with the given ok flag\n\n    Args:\n        msg(str): the message to log/print\n        ok(bool): if True show \u2705 marker else \u274c\n\n    Return:\n        bool: the ok parameter for fluid syntax\n    \"\"\"\n    marker = \"\u2705\" if ok else \"\u274c\"\n    print(f\"{msg}:{marker}\")\n    return ok\n</code></pre>"},{"location":"#mwdocker.mariadb","title":"<code>mariadb</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#mwdocker.mariadb.MariaDB","title":"<code>MariaDB</code>","text":"<p>Maria DB handling</p> Source code in <code>mwdocker/mariadb.py</code> <pre><code>class MariaDB:\n    \"\"\"\n    Maria DB handling\n    \"\"\"\n\n    @classmethod\n    def getVersion(cls, versionStr: str) -&gt; str:\n        \"\"\"\n        get the version from the version String\n\n        Args:\n            versionStr(str): the version string to check\n\n        Return:\n            str: the extracted version\n        \"\"\"\n        # version is anything which is not a dot at beginning\n        # two times may be ending with dash\n        version_match = re.search(r\"([^.]+[.]+[^.-]+)\", versionStr)\n        version = \"?\"\n        if version_match:\n            version = version_match.group(1)\n        return version\n</code></pre>"},{"location":"#mwdocker.mariadb.MariaDB.getVersion","title":"<code>getVersion(versionStr)</code>  <code>classmethod</code>","text":"<p>get the version from the version String</p> <p>Parameters:</p> Name Type Description Default <code>versionStr(str)</code> <p>the version string to check</p> required Return <p>str: the extracted version</p> Source code in <code>mwdocker/mariadb.py</code> <pre><code>@classmethod\ndef getVersion(cls, versionStr: str) -&gt; str:\n    \"\"\"\n    get the version from the version String\n\n    Args:\n        versionStr(str): the version string to check\n\n    Return:\n        str: the extracted version\n    \"\"\"\n    # version is anything which is not a dot at beginning\n    # two times may be ending with dash\n    version_match = re.search(r\"([^.]+[.]+[^.-]+)\", versionStr)\n    version = \"?\"\n    if version_match:\n        version = version_match.group(1)\n    return version\n</code></pre>"},{"location":"#mwdocker.mw","title":"<code>mw</code>","text":"<p>Created on 2021-06-23</p> <p>@author: wf</p>"},{"location":"#mwdocker.mw.Extension","title":"<code>Extension</code>","text":"<p>represents a MediaWiki extension</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@lod_storable\nclass Extension:\n    \"\"\"\n    represents a MediaWiki extension\n    \"\"\"\n\n    name: str\n    url: str\n    extension: Optional[str] = None\n    purpose: Optional[str] = None\n    giturl: Optional[str] = None\n    composer: Optional[str] = None\n    wikidata_id: Optional[str] = None\n    since: Optional[str] = None\n    localSettings: Optional[str] = None\n    require_once_until: Optional[str] = None\n    tagmap: Optional[Dict[str, str]] = None  # optionally map MediaWiki REL branches e.g. { \"REL1_39\": \"0.14.0\" }\n\n    @classmethod\n    def getSamples(cls):\n        samplesLOD = [\n            {\n                \"name\": \"Admin Links\",\n                \"extension\": \"AdminLinks\",\n                \"url\": \"https://www.mediawiki.org/wiki/Extension:Admin_Links\",\n                \"purpose\": \"\"\"Admin Links is an extension to MediaWiki that defines a special page, \"Special:AdminLinks\",\nthat holds links meant to be helpful for wiki administrators;\nit is meant to serve as a \"control panel\" for the functions an administrator would typically perform in a wiki.\nAll users can view this page; however, for those with the 'adminlinks' permission (sysops/administrators, by default),\na link to the page also shows up in their \"Personal URLs\", between \"Talk\" and \"Preferences\".\"\"\",\n                \"since\": datetime.fromisoformat(\"2009-05-13\"),\n                \"giturl\": \"https://gerrit.wikimedia.org/r/mediawiki/extensions/AdminLinks.git\",\n                \"localSettings\": \"\",\n            }\n        ]\n        return samplesLOD\n\n    @classmethod\n    def fromSpecialVersionTR(cls, exttr, debug=False):\n        \"\"\"\n        Construct an extension from a beautifl soup TR tag\n        derived from Special:Version\n\n        Args:\n            exttr: the beautiful soup TR tag\n            debug(bool): if True show debugging information\n        \"\"\"\n        ext = None\n        purpose = None\n        extNameTag = exttr.find(attrs={\"class\": \"mw-version-ext-name\"})\n        extPurposeTag = exttr.find(attrs={\"class\": \"mw-version-ext-description\"})\n        if extNameTag:\n            name = extNameTag.string\n            extension = name.replace(\" \", \"\")\n            url = extNameTag.get(\"href\")\n            if extPurposeTag and extPurposeTag.string:\n                purpose = extPurposeTag.string\n            ext = Extension(name=name, extension=extension, url=url, purpose=purpose)\n            ext.getDetailsFromUrl(debug=debug)\n        return ext\n\n    def __str__(self):\n        text = \"\"\n        delim = \"\"\n        samples = self.getSamples()\n        for attr in LOD.getFields(samples):\n            if hasattr(self, attr) and getattr(self, attr):\n                text += f\"{delim}{attr}={getattr(self,attr)}\"\n                delim = \"\\n\"\n        return text\n\n    def getDetailsFromUrl(self, showHtml=False, debug=False):\n        \"\"\"\n        get more details from my url\n        \"\"\"\n        webscrape = WebScrape()\n        try:\n            soup = webscrape.getSoup(self.url, showHtml=showHtml)\n            for link in soup.findAll(\"a\", attrs={\"class\": \"external text\"}):\n                if (\"GitHub\" == link.string) or (\"git repository URL\") == link.string:\n                    self.giturl = link.get(\"href\")\n        except urllib.error.HTTPError as herr:\n            if debug:\n                print(f\"HTTPError {str(herr)} for {self.url}\")\n\n    def asWikiMarkup(self):\n        \"\"\"\n        return me as wiki Markup\n        \"\"\"\n        samples = self.getJsonTypeSamples()\n        nameValues = \"\"\n        for attr in LOD.getFields(samples):\n            if hasattr(self, attr) and getattr(self, attr):\n                nameValues += f\"|{attr}={getattr(self,attr)}\\n\"\n        wikison = f\"\"\"{{{{Extension\n{nameValues}\n}}}}\"\"\"\n        return wikison\n\n    def getLocalSettingsLine(self, mwShortVersion: str):\n        \"\"\"\n        get my local settings line\n\n        Args:\n            mwShortVersion(str): the MediaWiki short version e.g. 127\n\n        Returns:\n            entry for LocalSettings\n        \"\"\"\n        localSettingsLine = \"\"\n        if self.extension:\n            localSettingsLine = f\"wfLoadExtension( '{self.extension}' );\"\n        if self.require_once_until:\n            if self.require_once_until &gt;= mwShortVersion:\n                localSettingsLine = f'require_once \"$IP/extensions/{self.extension}/{self.extension}.php\";'\n\n        if self.localSettings:\n            localSettingsLine += f\"\\n  {self.localSettings}\"\n        return localSettingsLine\n\n    def asScript(self, branch: str = \"master\") -&gt; str:\n        \"\"\"\n        return me as a shell script command line string\n\n        Args:\n            branch (str): the MediaWiki branch (e.g. REL1_39)\n        \"\"\"\n        script = \"\"\n        if self.giturl:\n            options = \"\"\n            # check if tagmap defines a tag for this branch\n            tag = None\n            if self.tagmap:\n                tag = self.tagmap.get(branch)\n            if tag:\n                # use the mapped tag\n                options = f'--branch {tag}'\n            elif \"//github.com/wikimedia/\" in self.giturl or \"//gerrit.wikimedia.org\" in self.giturl:\n                # default WMF convention: branch per MediaWiki REL\n                options = f'--single-branch --branch {branch}'\n            script = f'git_get \"{self.giturl}\" \"{self.extension}\" \"{options}\"'\n        else:\n            script = \"# no installation script command specified\"\n            if self.composer:\n                script += f\"\\n# installed with composer require {self.composer}\"\n        return script\n</code></pre>"},{"location":"#mwdocker.mw.Extension.asScript","title":"<code>asScript(branch='master')</code>","text":"<p>return me as a shell script command line string</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>the MediaWiki branch (e.g. REL1_39)</p> <code>'master'</code> Source code in <code>mwdocker/mw.py</code> <pre><code>def asScript(self, branch: str = \"master\") -&gt; str:\n    \"\"\"\n    return me as a shell script command line string\n\n    Args:\n        branch (str): the MediaWiki branch (e.g. REL1_39)\n    \"\"\"\n    script = \"\"\n    if self.giturl:\n        options = \"\"\n        # check if tagmap defines a tag for this branch\n        tag = None\n        if self.tagmap:\n            tag = self.tagmap.get(branch)\n        if tag:\n            # use the mapped tag\n            options = f'--branch {tag}'\n        elif \"//github.com/wikimedia/\" in self.giturl or \"//gerrit.wikimedia.org\" in self.giturl:\n            # default WMF convention: branch per MediaWiki REL\n            options = f'--single-branch --branch {branch}'\n        script = f'git_get \"{self.giturl}\" \"{self.extension}\" \"{options}\"'\n    else:\n        script = \"# no installation script command specified\"\n        if self.composer:\n            script += f\"\\n# installed with composer require {self.composer}\"\n    return script\n</code></pre>"},{"location":"#mwdocker.mw.Extension.asWikiMarkup","title":"<code>asWikiMarkup()</code>","text":"<p>return me as wiki Markup</p> Source code in <code>mwdocker/mw.py</code> <pre><code>    def asWikiMarkup(self):\n        \"\"\"\n        return me as wiki Markup\n        \"\"\"\n        samples = self.getJsonTypeSamples()\n        nameValues = \"\"\n        for attr in LOD.getFields(samples):\n            if hasattr(self, attr) and getattr(self, attr):\n                nameValues += f\"|{attr}={getattr(self,attr)}\\n\"\n        wikison = f\"\"\"{{{{Extension\n{nameValues}\n}}}}\"\"\"\n        return wikison\n</code></pre>"},{"location":"#mwdocker.mw.Extension.fromSpecialVersionTR","title":"<code>fromSpecialVersionTR(exttr, debug=False)</code>  <code>classmethod</code>","text":"<p>Construct an extension from a beautifl soup TR tag derived from Special:Version</p> <p>Parameters:</p> Name Type Description Default <code>exttr</code> <p>the beautiful soup TR tag</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required Source code in <code>mwdocker/mw.py</code> <pre><code>@classmethod\ndef fromSpecialVersionTR(cls, exttr, debug=False):\n    \"\"\"\n    Construct an extension from a beautifl soup TR tag\n    derived from Special:Version\n\n    Args:\n        exttr: the beautiful soup TR tag\n        debug(bool): if True show debugging information\n    \"\"\"\n    ext = None\n    purpose = None\n    extNameTag = exttr.find(attrs={\"class\": \"mw-version-ext-name\"})\n    extPurposeTag = exttr.find(attrs={\"class\": \"mw-version-ext-description\"})\n    if extNameTag:\n        name = extNameTag.string\n        extension = name.replace(\" \", \"\")\n        url = extNameTag.get(\"href\")\n        if extPurposeTag and extPurposeTag.string:\n            purpose = extPurposeTag.string\n        ext = Extension(name=name, extension=extension, url=url, purpose=purpose)\n        ext.getDetailsFromUrl(debug=debug)\n    return ext\n</code></pre>"},{"location":"#mwdocker.mw.Extension.getDetailsFromUrl","title":"<code>getDetailsFromUrl(showHtml=False, debug=False)</code>","text":"<p>get more details from my url</p> Source code in <code>mwdocker/mw.py</code> <pre><code>def getDetailsFromUrl(self, showHtml=False, debug=False):\n    \"\"\"\n    get more details from my url\n    \"\"\"\n    webscrape = WebScrape()\n    try:\n        soup = webscrape.getSoup(self.url, showHtml=showHtml)\n        for link in soup.findAll(\"a\", attrs={\"class\": \"external text\"}):\n            if (\"GitHub\" == link.string) or (\"git repository URL\") == link.string:\n                self.giturl = link.get(\"href\")\n    except urllib.error.HTTPError as herr:\n        if debug:\n            print(f\"HTTPError {str(herr)} for {self.url}\")\n</code></pre>"},{"location":"#mwdocker.mw.Extension.getLocalSettingsLine","title":"<code>getLocalSettingsLine(mwShortVersion)</code>","text":"<p>get my local settings line</p> <p>Parameters:</p> Name Type Description Default <code>mwShortVersion(str)</code> <p>the MediaWiki short version e.g. 127</p> required <p>Returns:</p> Type Description <p>entry for LocalSettings</p> Source code in <code>mwdocker/mw.py</code> <pre><code>def getLocalSettingsLine(self, mwShortVersion: str):\n    \"\"\"\n    get my local settings line\n\n    Args:\n        mwShortVersion(str): the MediaWiki short version e.g. 127\n\n    Returns:\n        entry for LocalSettings\n    \"\"\"\n    localSettingsLine = \"\"\n    if self.extension:\n        localSettingsLine = f\"wfLoadExtension( '{self.extension}' );\"\n    if self.require_once_until:\n        if self.require_once_until &gt;= mwShortVersion:\n            localSettingsLine = f'require_once \"$IP/extensions/{self.extension}/{self.extension}.php\";'\n\n    if self.localSettings:\n        localSettingsLine += f\"\\n  {self.localSettings}\"\n    return localSettingsLine\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList","title":"<code>ExtensionList</code>","text":"<p>represents a list of MediaWiki extensions</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@lod_storable\nclass ExtensionList:\n    \"\"\"\n    represents a list of MediaWiki extensions\n    \"\"\"\n\n    extensions: List[Extension] = field(default_factory=list)\n\n    @staticmethod\n    def storeFilePrefix():\n        \"\"\"\n        get my storeFilePrefix\n\n        Returns:\n            str: the path to where my stored files (e.g. JSON) should be kept\n        \"\"\"\n        scriptdir = os.path.dirname(os.path.realpath(__file__))\n        resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n        storeFilePrefix = f\"{resourcePath}/extensions\"\n        return storeFilePrefix\n\n    @classmethod\n    def fromSpecialVersion(\n        cls, url: str, excludes=[\"skin\", \"editor\"], showHtml=False, debug=False\n    ):\n        \"\"\"\n        get an extension List from the given url\n\n        Args:\n            url(str): the Special:Version MediaWiki page to read the information from\n            exclude (list): a list of types of extensions to exclude\n            showHtml(bool): True if the html code should be printed for debugging\n            debug(bool): True if debugging should be active\n\n        Returns:\n            ExtensionList: an extension list derived from the url\n        \"\"\"\n        webscrape = WebScrape()\n        soup = webscrape.getSoup(url, showHtml=showHtml)\n\n        # search for\n        # &lt;tr class=\"mw-version-ext\" id=\"mw-version-ext-media-PDF_Handler\"&gt;\n        exttrs = soup.findAll(attrs={\"class\": \"mw-version-ext\"})\n        extList = ExtensionList()\n        for exttr in exttrs:\n            if showHtml:\n                print(exttr)\n            doExclude = False\n            for exclude in excludes:\n                if f\"-{exclude}-\" in exttr.get(\"id\"):\n                    doExclude = True\n            if not doExclude:\n                ext = Extension.fromSpecialVersionTR(exttr, debug=debug)\n                if ext:\n                    extList.extensions.append(ext)\n        return extList\n\n    @classmethod\n    def restore(cls) -&gt; \"ExtensionList\":\n        \"\"\"\n        restore the extension list\n        \"\"\"\n        path = ExtensionList.storeFilePrefix()\n        yaml_file = f\"{path}.yaml\"\n        extlist = ExtensionList.load_from_yaml_file(yaml_file)\n        return extlist\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList.fromSpecialVersion","title":"<code>fromSpecialVersion(url, excludes=['skin', 'editor'], showHtml=False, debug=False)</code>  <code>classmethod</code>","text":"<p>get an extension List from the given url</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the Special:Version MediaWiki page to read the information from</p> required <code>exclude</code> <code>list</code> <p>a list of types of extensions to exclude</p> required <code>showHtml(bool)</code> <p>True if the html code should be printed for debugging</p> required <code>debug(bool)</code> <p>True if debugging should be active</p> required <p>Returns:</p> Name Type Description <code>ExtensionList</code> <p>an extension list derived from the url</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@classmethod\ndef fromSpecialVersion(\n    cls, url: str, excludes=[\"skin\", \"editor\"], showHtml=False, debug=False\n):\n    \"\"\"\n    get an extension List from the given url\n\n    Args:\n        url(str): the Special:Version MediaWiki page to read the information from\n        exclude (list): a list of types of extensions to exclude\n        showHtml(bool): True if the html code should be printed for debugging\n        debug(bool): True if debugging should be active\n\n    Returns:\n        ExtensionList: an extension list derived from the url\n    \"\"\"\n    webscrape = WebScrape()\n    soup = webscrape.getSoup(url, showHtml=showHtml)\n\n    # search for\n    # &lt;tr class=\"mw-version-ext\" id=\"mw-version-ext-media-PDF_Handler\"&gt;\n    exttrs = soup.findAll(attrs={\"class\": \"mw-version-ext\"})\n    extList = ExtensionList()\n    for exttr in exttrs:\n        if showHtml:\n            print(exttr)\n        doExclude = False\n        for exclude in excludes:\n            if f\"-{exclude}-\" in exttr.get(\"id\"):\n                doExclude = True\n        if not doExclude:\n            ext = Extension.fromSpecialVersionTR(exttr, debug=debug)\n            if ext:\n                extList.extensions.append(ext)\n    return extList\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList.restore","title":"<code>restore()</code>  <code>classmethod</code>","text":"<p>restore the extension list</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@classmethod\ndef restore(cls) -&gt; \"ExtensionList\":\n    \"\"\"\n    restore the extension list\n    \"\"\"\n    path = ExtensionList.storeFilePrefix()\n    yaml_file = f\"{path}.yaml\"\n    extlist = ExtensionList.load_from_yaml_file(yaml_file)\n    return extlist\n</code></pre>"},{"location":"#mwdocker.mw.ExtensionList.storeFilePrefix","title":"<code>storeFilePrefix()</code>  <code>staticmethod</code>","text":"<p>get my storeFilePrefix</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the path to where my stored files (e.g. JSON) should be kept</p> Source code in <code>mwdocker/mw.py</code> <pre><code>@staticmethod\ndef storeFilePrefix():\n    \"\"\"\n    get my storeFilePrefix\n\n    Returns:\n        str: the path to where my stored files (e.g. JSON) should be kept\n    \"\"\"\n    scriptdir = os.path.dirname(os.path.realpath(__file__))\n    resourcePath = os.path.realpath(f\"{scriptdir}/resources\")\n    storeFilePrefix = f\"{resourcePath}/extensions\"\n    return storeFilePrefix\n</code></pre>"},{"location":"#mwdocker.mwcluster","title":"<code>mwcluster</code>","text":"<p>Created on 2021-08-06 @author: wf</p>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster","title":"<code>MediaWikiCluster</code>","text":"<p>               Bases: <code>object</code></p> <p>a cluster of mediawiki docker Applications</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>class MediaWikiCluster(object):\n    \"\"\"\n    a cluster of mediawiki docker Applications\n    \"\"\"\n\n    # https://hub.docker.com/_/mediawiki\n    # 2023-01-13\n    # MediaWiki Extensions and Skins Security Release Supplement (1.35.9/1.38.4/1.39.1)\n    # 2023-02-23 1.39.2 released\n    # 2023-04-04 1.39.3 upgrade\n    # 2023-10-04 1.39.5 upgrade\n    # 2024-04-15 1.39.7 upgrade\n    # 2024-08-02 1.39.8 upgrade\n    # 2024-10-11 1.39.10 upgrade\n    # 2025-03-18 1.39.11 upgrade 1.43.0 addition\n    # 2025-04-13 Security and maintenance release: 1.39.12 / 1.42.6 / 1.43.1\n    # 2025-06-30 Security and maintenance release: 1.39.13 / 1.42.7 / 1.43.3\n    # 2025-10-05 Security and maintenance release: 1.39.14 / 1.43.4 / 1.44.1\n    # 2025-11-14 Security and maintenance release: 1.39.15 / 1.43.5 / 1.44.2\n\n    def __init__(self, config: MwClusterConfig,args:Namespace=None):\n        \"\"\"\n        Constructor\n\n        Args:\n            config(MWClusterConfig): the MediaWiki Cluster Configuration to use\n        \"\"\"\n        self.config = config\n        self.args=args\n        self.apps = {}\n\n    def createApps(self, withGenerate: bool = True) -&gt; dict:\n        \"\"\"\n        create my apps\n\n        Args:\n            withGenerate(bool): if True generate the config files\n\n        Returns:\n            dict(str): a dict of apps by version\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            raise ValueError(\"createApps needs docker command in PATH\")\n        app_count = len(self.config.versions)\n        for i, version in enumerate(self.config.versions):\n            mwApp = self.getDockerApplication(i, app_count, version)\n            if withGenerate:\n                mwApp.generateAll(overwrite=self.config.forceRebuild)\n            self.apps[version] = mwApp\n        return self.apps\n\n    def checkDocker(self) -&gt; int:\n        \"\"\"\n        check the Docker environment\n\n        print an error message on stderr if check fails\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n\n        \"\"\"\n        errMsg = DockerApplication.checkDockerEnvironment(self.config.debug)\n        if errMsg is not None:\n            print(errMsg, file=sys.stderr)\n            return 1\n        return 0\n\n    def start(self, forceRebuild: bool = False, withInitDB=True) -&gt; int:\n        \"\"\"\n        create and start the composer applications\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n\n        for version in self.config.versions:\n            mwApp = self.apps[version]\n            mwApp.start(forceRebuild=forceRebuild, withInitDB=withInitDB)\n        return 0\n\n    def down(self, forceRebuild: bool = False):\n        \"\"\"\n        run docker compose down\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n        for _i, version in enumerate(self.config.versions):\n            mwApp = self.apps[version]\n            mwApp.down(forceRebuild)\n\n    def listWikis(self) -&gt; int:\n        \"\"\"\n        list my wikis\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n        for i, version in enumerate(self.config.versions):\n            mwApp = self.apps[version]\n            mw, db = mwApp.getContainers()\n            config = mwApp.config\n            ok = mw and db\n            msg = f\"{i+1}:{config.container_base_name} {config.fullVersion}\"\n            Logger.check_and_log(msg, ok)\n        return exitCode\n\n    def check(self) -&gt; int:\n        \"\"\"\n        check the composer applications\n\n        Returns:\n            int: exitCode - 0 if ok 1 if failed\n        \"\"\"\n        exitCode = self.checkDocker()\n        if exitCode &gt; 0:\n            return exitCode\n\n        for i, version in enumerate(self.config.versions):\n            mwApp = self.apps[version]\n            msg = f\"{i+1}:checking {version} ...\"\n            print(msg)\n            exitCode = mwApp.check()\n        return exitCode\n\n    def close(self):\n        \"\"\"\n        close my apps\n        \"\"\"\n        for mwApp in self.apps.values():\n            mwApp.close()\n\n    def getDockerApplication(self, i: int, count: int, version: str):\n        \"\"\"\n        get the docker application for the given version index and version\n\n        Args:\n            i(int): the index of the version\n            count(int): total number of Docker applications in this cluster\n            version(str): the mediawiki version to use\n\n        Returns:\n            DockerApplication: the docker application\n        \"\"\"\n        # please note that we are using the subclass MwClusterConfig here although\n        # we only need the superclass MwConfig - we let inheritance work here for us but\n        # have to ignore the superfluous fields\n        appConfig = dataclasses.replace(self.config)\n        appConfig.extensionMap = self.config.extensionMap.copy()\n        appConfig.version = version\n        appConfig.base_port = self.config.base_port + i\n        appConfig.port = self.config.base_port + i\n        appConfig.sql_port = self.config.sql_port + i\n        # let post_init create a new container_base_name and db_container_name\n        if count &gt; 1:\n            appConfig.container_base_name = None\n            appConfig.db_container_name = self.args.db_container_name if self.args else None\n        appConfig.__post_init__()\n        mwApp = DockerApplication(config=appConfig)\n        return mwApp\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.__init__","title":"<code>__init__(config, args=None)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>config(MWClusterConfig)</code> <p>the MediaWiki Cluster Configuration to use</p> required Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def __init__(self, config: MwClusterConfig,args:Namespace=None):\n    \"\"\"\n    Constructor\n\n    Args:\n        config(MWClusterConfig): the MediaWiki Cluster Configuration to use\n    \"\"\"\n    self.config = config\n    self.args=args\n    self.apps = {}\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.check","title":"<code>check()</code>","text":"<p>check the composer applications</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def check(self) -&gt; int:\n    \"\"\"\n    check the composer applications\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n\n    for i, version in enumerate(self.config.versions):\n        mwApp = self.apps[version]\n        msg = f\"{i+1}:checking {version} ...\"\n        print(msg)\n        exitCode = mwApp.check()\n    return exitCode\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.checkDocker","title":"<code>checkDocker()</code>","text":"<p>check the Docker environment</p> <p>print an error message on stderr if check fails</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def checkDocker(self) -&gt; int:\n    \"\"\"\n    check the Docker environment\n\n    print an error message on stderr if check fails\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n\n    \"\"\"\n    errMsg = DockerApplication.checkDockerEnvironment(self.config.debug)\n    if errMsg is not None:\n        print(errMsg, file=sys.stderr)\n        return 1\n    return 0\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.close","title":"<code>close()</code>","text":"<p>close my apps</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def close(self):\n    \"\"\"\n    close my apps\n    \"\"\"\n    for mwApp in self.apps.values():\n        mwApp.close()\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.createApps","title":"<code>createApps(withGenerate=True)</code>","text":"<p>create my apps</p> <p>Parameters:</p> Name Type Description Default <code>withGenerate(bool)</code> <p>if True generate the config files</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>str</code> <p>a dict of apps by version</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def createApps(self, withGenerate: bool = True) -&gt; dict:\n    \"\"\"\n    create my apps\n\n    Args:\n        withGenerate(bool): if True generate the config files\n\n    Returns:\n        dict(str): a dict of apps by version\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        raise ValueError(\"createApps needs docker command in PATH\")\n    app_count = len(self.config.versions)\n    for i, version in enumerate(self.config.versions):\n        mwApp = self.getDockerApplication(i, app_count, version)\n        if withGenerate:\n            mwApp.generateAll(overwrite=self.config.forceRebuild)\n        self.apps[version] = mwApp\n    return self.apps\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.down","title":"<code>down(forceRebuild=False)</code>","text":"<p>run docker compose down</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def down(self, forceRebuild: bool = False):\n    \"\"\"\n    run docker compose down\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n    for _i, version in enumerate(self.config.versions):\n        mwApp = self.apps[version]\n        mwApp.down(forceRebuild)\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.getDockerApplication","title":"<code>getDockerApplication(i, count, version)</code>","text":"<p>get the docker application for the given version index and version</p> <p>Parameters:</p> Name Type Description Default <code>i(int)</code> <p>the index of the version</p> required <code>count(int)</code> <p>total number of Docker applications in this cluster</p> required <code>version(str)</code> <p>the mediawiki version to use</p> required <p>Returns:</p> Name Type Description <code>DockerApplication</code> <p>the docker application</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def getDockerApplication(self, i: int, count: int, version: str):\n    \"\"\"\n    get the docker application for the given version index and version\n\n    Args:\n        i(int): the index of the version\n        count(int): total number of Docker applications in this cluster\n        version(str): the mediawiki version to use\n\n    Returns:\n        DockerApplication: the docker application\n    \"\"\"\n    # please note that we are using the subclass MwClusterConfig here although\n    # we only need the superclass MwConfig - we let inheritance work here for us but\n    # have to ignore the superfluous fields\n    appConfig = dataclasses.replace(self.config)\n    appConfig.extensionMap = self.config.extensionMap.copy()\n    appConfig.version = version\n    appConfig.base_port = self.config.base_port + i\n    appConfig.port = self.config.base_port + i\n    appConfig.sql_port = self.config.sql_port + i\n    # let post_init create a new container_base_name and db_container_name\n    if count &gt; 1:\n        appConfig.container_base_name = None\n        appConfig.db_container_name = self.args.db_container_name if self.args else None\n    appConfig.__post_init__()\n    mwApp = DockerApplication(config=appConfig)\n    return mwApp\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.listWikis","title":"<code>listWikis()</code>","text":"<p>list my wikis</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def listWikis(self) -&gt; int:\n    \"\"\"\n    list my wikis\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n    for i, version in enumerate(self.config.versions):\n        mwApp = self.apps[version]\n        mw, db = mwApp.getContainers()\n        config = mwApp.config\n        ok = mw and db\n        msg = f\"{i+1}:{config.container_base_name} {config.fullVersion}\"\n        Logger.check_and_log(msg, ok)\n    return exitCode\n</code></pre>"},{"location":"#mwdocker.mwcluster.MediaWikiCluster.start","title":"<code>start(forceRebuild=False, withInitDB=True)</code>","text":"<p>create and start the composer applications</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exitCode - 0 if ok 1 if failed</p> Source code in <code>mwdocker/mwcluster.py</code> <pre><code>def start(self, forceRebuild: bool = False, withInitDB=True) -&gt; int:\n    \"\"\"\n    create and start the composer applications\n\n    Returns:\n        int: exitCode - 0 if ok 1 if failed\n    \"\"\"\n    exitCode = self.checkDocker()\n    if exitCode &gt; 0:\n        return exitCode\n\n    for version in self.config.versions:\n        mwApp = self.apps[version]\n        mwApp.start(forceRebuild=forceRebuild, withInitDB=withInitDB)\n    return 0\n</code></pre>"},{"location":"#mwdocker.mwdocker_cmd","title":"<code>mwdocker_cmd</code>","text":"<p>Created on 2025-08-01</p> <p>@author: wf</p>"},{"location":"#mwdocker.mwdocker_cmd.MediaWikiDockerCmd","title":"<code>MediaWikiDockerCmd</code>","text":"<p>               Bases: <code>BaseCmd</code></p> <p>pymediawiki docker main</p> Source code in <code>mwdocker/mwdocker_cmd.py</code> <pre><code>class MediaWikiDockerCmd(BaseCmd):\n    \"\"\"\n    pymediawiki docker main\n    \"\"\"\n\n    def __init__(self, version=Version):\n        super().__init__(version)\n        self.config = MwClusterConfig()\n        self.cluster = None\n\n    def getMwConfig(self, argv=None, version=None) -&gt; MwClusterConfig:\n        \"\"\"\n        get a mediawiki configuration for the given command line arguments\n        \"\"\"\n        if not argv:\n            argv = self.argv\n        parser = ArgumentParser()\n        if version is None:\n            version = MwConfig.version\n        mwClusterConfig = MwClusterConfig(version=version)\n        self.config = mwClusterConfig\n        self.add_arguments(parser)\n        args = parser.parse_args(argv)\n        mwClusterConfig.fromArgs(args)\n        return mwClusterConfig\n\n    def add_arguments(self, parser: ArgumentParser):\n        \"\"\"\n        add parser arguments\n        \"\"\"\n        super().add_arguments(parser)\n        self.config.addArgs(parser)\n        parser.add_argument(\"--create\", action=\"store_true\")\n        parser.add_argument(\"--down\", action=\"store_true\")\n        parser.add_argument(\"--check\", action=\"store_true\")\n        parser.add_argument(\"--list\", action=\"store_true\")\n\n    def handle_args(self, args: Namespace) -&gt; bool:\n        if super().handle_args(args):\n            return True\n        self.config.fromArgs(args)\n        self.cluster = MediaWikiCluster(self.config,args)\n        self.cluster.createApps(withGenerate=args.create)\n        if args.check:\n            self.exit_code = self.cluster.check()\n        elif args.create:\n            self.exit_code = self.cluster.start(forceRebuild=self.config.forceRebuild)\n        elif args.list:\n            self.exit_code = self.cluster.listWikis()\n        elif args.down:\n            self.exit_code = self.cluster.down(forceRebuild=self.config.forceRebuild)\n        else:\n            self.parser.print_usage()\n            self.exit_code = 1\n        return True\n</code></pre>"},{"location":"#mwdocker.mwdocker_cmd.MediaWikiDockerCmd.add_arguments","title":"<code>add_arguments(parser)</code>","text":"<p>add parser arguments</p> Source code in <code>mwdocker/mwdocker_cmd.py</code> <pre><code>def add_arguments(self, parser: ArgumentParser):\n    \"\"\"\n    add parser arguments\n    \"\"\"\n    super().add_arguments(parser)\n    self.config.addArgs(parser)\n    parser.add_argument(\"--create\", action=\"store_true\")\n    parser.add_argument(\"--down\", action=\"store_true\")\n    parser.add_argument(\"--check\", action=\"store_true\")\n    parser.add_argument(\"--list\", action=\"store_true\")\n</code></pre>"},{"location":"#mwdocker.mwdocker_cmd.MediaWikiDockerCmd.getMwConfig","title":"<code>getMwConfig(argv=None, version=None)</code>","text":"<p>get a mediawiki configuration for the given command line arguments</p> Source code in <code>mwdocker/mwdocker_cmd.py</code> <pre><code>def getMwConfig(self, argv=None, version=None) -&gt; MwClusterConfig:\n    \"\"\"\n    get a mediawiki configuration for the given command line arguments\n    \"\"\"\n    if not argv:\n        argv = self.argv\n    parser = ArgumentParser()\n    if version is None:\n        version = MwConfig.version\n    mwClusterConfig = MwClusterConfig(version=version)\n    self.config = mwClusterConfig\n    self.add_arguments(parser)\n    args = parser.parse_args(argv)\n    mwClusterConfig.fromArgs(args)\n    return mwClusterConfig\n</code></pre>"},{"location":"#mwdocker.version","title":"<code>version</code>","text":"<p>Created on 2022-04-07</p> <p>@author: wf</p>"},{"location":"#mwdocker.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pymediawikidocker</p> Source code in <code>mwdocker/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pymediawikidocker\n    \"\"\"\n\n    name = \"pymediawikidocker\"\n    version = mwdocker.__version__\n    date = \"2021-06-21\"\n    updated = \"2025-12-16\"\n\n    authors = \"Wolfgang Fahl, Tim Holzheim\"\n\n    description = (\n        \"Python controlled (semantic) mediawiki docker application cluster installation\"\n    )\n\n    cm_url = \"https://github.com/WolfgangFahl/pymediawikidocker\"\n    chat_url = \"https://github.com/WolfgangFahl/pymediawikidocker/discussions\"\n    doc_url = \"https://wiki.bitplan.com/index.php/Pymediawikidocker\"\n\n    license = f\"\"\"Copyright 2020-2025 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#mwdocker.webscrape","title":"<code>webscrape</code>","text":"<p>Created on 2020-08-20</p> <p>@author: wf</p>"},{"location":"#mwdocker.webscrape.WebScrape","title":"<code>WebScrape</code>","text":"<p>               Bases: <code>object</code></p> <p>WebScraper</p> Source code in <code>mwdocker/webscrape.py</code> <pre><code>class WebScrape(object):\n    \"\"\"\n    WebScraper\n    \"\"\"\n\n    def __init__(self, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.err = None\n        self.valid = False\n        self.debug = debug\n        self.showHtml = showHtml\n\n    def getSoup(self, url, showHtml):\n        \"\"\"\n        get the beautiful Soup parser\n\n        Args:\n           showHtml(boolean): True if the html code should be pretty printed and shown\n        \"\"\"\n        req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n        html = urlopen(req).read()\n        soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n        if showHtml:\n            self.printPrettyHtml(soup)\n\n        return soup\n\n    def printPrettyHtml(self, soup):\n        \"\"\"\n        print the prettified html for the given soup\n\n        Args:\n            soup(BeuatifulSoup): the parsed html to print\n        \"\"\"\n        prettyHtml = soup.prettify()\n        print(prettyHtml)\n</code></pre>"},{"location":"#mwdocker.webscrape.WebScrape.__init__","title":"<code>__init__(debug=False, showHtml=False)</code>","text":"<p>Constructor</p> Source code in <code>mwdocker/webscrape.py</code> <pre><code>def __init__(self, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.err = None\n    self.valid = False\n    self.debug = debug\n    self.showHtml = showHtml\n</code></pre>"},{"location":"#mwdocker.webscrape.WebScrape.getSoup","title":"<code>getSoup(url, showHtml)</code>","text":"<p>get the beautiful Soup parser</p> <p>Parameters:</p> Name Type Description Default <code>showHtml(boolean)</code> <p>True if the html code should be pretty printed and shown</p> required Source code in <code>mwdocker/webscrape.py</code> <pre><code>def getSoup(self, url, showHtml):\n    \"\"\"\n    get the beautiful Soup parser\n\n    Args:\n       showHtml(boolean): True if the html code should be pretty printed and shown\n    \"\"\"\n    req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n    html = urlopen(req).read()\n    soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n    if showHtml:\n        self.printPrettyHtml(soup)\n\n    return soup\n</code></pre>"},{"location":"#mwdocker.webscrape.WebScrape.printPrettyHtml","title":"<code>printPrettyHtml(soup)</code>","text":"<p>print the prettified html for the given soup</p> <p>Parameters:</p> Name Type Description Default <code>soup(BeuatifulSoup)</code> <p>the parsed html to print</p> required Source code in <code>mwdocker/webscrape.py</code> <pre><code>def printPrettyHtml(self, soup):\n    \"\"\"\n    print the prettified html for the given soup\n\n    Args:\n        soup(BeuatifulSoup): the parsed html to print\n    \"\"\"\n    prettyHtml = soup.prettify()\n    print(prettyHtml)\n</code></pre>"}]}